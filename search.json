[
  {
    "objectID": "general_functions.html",
    "href": "general_functions.html",
    "title": "General Functions",
    "section": "",
    "text": "The functions in this module are not specific to any of the ITTC appendices",
    "crumbs": [
      "General Functions"
    ]
  },
  {
    "objectID": "general_functions.html#conversion-between-knots-and-meters-per-second",
    "href": "general_functions.html#conversion-between-knots-and-meters-per-second",
    "title": "General Functions",
    "section": "0.1 Conversion between knots and meters per second",
    "text": "0.1 Conversion between knots and meters per second\nAs many of the functions in this library require SI units it can be helpful to have a knots-m/s converter and vice-versa.\n\nsource\n\n0.1.1 knots_to_ms\n\n knots_to_ms (knots:float)\n\nconvert knots to m/s\n\n\n\n\nType\nDetails\n\n\n\n\nknots\nfloat\nthe speed in knots\n\n\nReturns\nfloat\nspeed in m/s\n\n\n\n\nsource\n\n\n0.1.2 ms_to_knots\n\n ms_to_knots (ms:float)\n\nconvert knots to m/s\n\n\n\n\nType\nDetails\n\n\n\n\nms\nfloat\nthe speed in m/s\n\n\nReturns\nfloat\nspeed in knots\n\n\n\nUsing these simple functions we can easily convert between knots and m/s\n\n#convert knots to m/s\nmeters_per_second = knots_to_ms(5)\nprint('speed converted to meters per second '+str(meters_per_second))\n#convert back to knots\nknots = ms_to_knots(meters_per_second)\nprint('speed converted back into knots '+str(knots))\n\nspeed converted to meters per second 2.572222873852017\nspeed converted back into knots 5.0",
    "crumbs": [
      "General Functions"
    ]
  },
  {
    "objectID": "general_functions.html#corrected-delivered-power",
    "href": "general_functions.html#corrected-delivered-power",
    "title": "General Functions",
    "section": "0.2 Corrected Delivered Power",
    "text": "0.2 Corrected Delivered Power\nFind the shaft power in ideal conditions considering an external (environmental) force acting on the ship. \\[P_{Did} = \\frac{1}{2} \\left(P_{Dms} - \\frac{\\Delta RV_s}{\\eta_{Did}} + \\sqrt{ \\left(P_{Dms} - \\frac{\\Delta RV_s}{\\eta_{Did}} \\right)^2 + 4P_{Dms} \\frac{\\Delta RV_s}{\\eta_{Did}} \\xi_P} \\right)\\] where:\n\\(P_{Did}\\) is the shaft power in ideal conditions [W],\n\\(P_{Dms}\\) is the measured shaft power [W],\n\\(\\Delta R\\) is the resistance increase due to wind, waves and temperature deviations [N]\n\\(V_S\\) is the ship’s speed through water [m/s],\n\\(\\eta_{Did}\\) is the propulsion efficiency coefficient in ideal conditions, from the model test,\n\\(\\xi_P\\) is the overload factor derived from load variation model test,\nITTC equations: 5\n\nsource\n\n0.2.1 power_correction\n\n power_correction (pd_meas:float, delta_R:float, stw:float, etaD_id:float,\n                   shaft_power_overload:float)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npd_meas\nfloat\nmeasured shaft power [W]\n\n\ndelta_R\nfloat\nincrease of resistance due to wind, waves and temperature deviation [N]\n\n\nstw\nfloat\nspeed through water [m/s]\n\n\netaD_id\nfloat\npropulsion efficiency coefficienct in ideal conditions (from model test) [-]\n\n\nshaft_power_overload\nfloat\noverload factor from load variation model test [-]\n\n\nReturns\nfloat\nshaft power in ideal conditions [W]\n\n\n\nWhat is the ideal power given the following inputs:\nmeasured power = 30,000 kW\ndelta R = 100000 N\nSTW = 8 m/s\netaD id = 0.75\nshaft power overload factor = -0.1\n\npower_correction(pd_meas = 30000000, #measured shaft power [W]\n                 delta_R = 100000, #increase of resistance due to wind, waves and temperature deviation [N]\n                 stw = 8, #speed through water [m/s]\n                 etaD_id = 0.75, #propulsion efficiency coefficienct in ideal conditions (from model test) [-]\n                 shaft_power_overload = -0.1 #overload factor from load variation model test [-]\n                 )\n\n28822308.221276633",
    "crumbs": [
      "General Functions"
    ]
  },
  {
    "objectID": "general_functions.html#corrected-propeller-shaft-revolution-frequency",
    "href": "general_functions.html#corrected-propeller-shaft-revolution-frequency",
    "title": "General Functions",
    "section": "0.3 Corrected Propeller Shaft Revolution Frequency",
    "text": "0.3 Corrected Propeller Shaft Revolution Frequency\nFind the propeller revolution frequency in ideal conditions considering the measured and ideal shaft power.\n\\[n_{id} = \\frac{n_{ms}}{\\xi_n \\frac{P_{Dms}-P_{Did}}{P_{Did}}+1}\\]\nWhere\n\\(n_{id}\\) is the propeller shaft revolution frequency in ideal conditions [1/s],\n\\(n_{ms}\\) is the measured propeller shaft revolution frequency [1/s],\n\\(\\xi_n\\) is the overload factor derived from load variation model test [-],\n\\(P_{Dms}\\) is the measured shaft power [W],\n\\(P_{Did}\\) is the shaft power in ideal conditions [W],\nITTC equations: 6\n\nsource\n\n0.3.1 shaft_speed_correction\n\n shaft_speed_correction (n_ms:float, shaft_speed_overload:float,\n                         pd_meas:float, pd_id:float)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nn_ms\nfloat\nmeasured propeller shaft revolution frequency [1/s]\n\n\nshaft_speed_overload\nfloat\noverload factor derived from load variation model test [-]\n\n\npd_meas\nfloat\nmeasured shaft power [W]\n\n\npd_id\nfloat\nshaft power in ideal conditions [W]\n\n\nReturns\nfloat\npropeller shaft revolution frequency in ideal condition [1/s]\n\n\n\nWhat is the ideal propeller shaft revolution frequency given the following inputs:\nmeasured propeller shaft revolution frequency = 1.1 1/s\noverload factor = 0.3\nmeasured shaft power = 30,000 kW\nideal shaft power = 28,822 kW\n\nshaft_speed_correction(n_ms = 1.1, #measured propeller shaft revolution frequency [1/s]\n                       shaft_speed_overload = 0.3, #overload factor derived from load variation model test [-]\n                       pd_meas = 30000000, #measured shaft power [W]\n                       pd_id =  28822000#shaft power in ideal conditions [W]\n                       )\n\n1.0866757610863946",
    "crumbs": [
      "General Functions"
    ]
  },
  {
    "objectID": "general_functions.html#wind-resistance",
    "href": "general_functions.html#wind-resistance",
    "title": "General Functions",
    "section": "0.4 Wind resistance",
    "text": "0.4 Wind resistance\nThe resistance experienced by the ship as a result of passing through air.\n\\[R_{AA} = \\frac{1}{2} \\rho_A A_{XV} \\left ( C_{DA}(\\psi_{WREF})  V_{WREF}^2 - C_{DA}(0)  V_{G}^2 \\right),\\] where \\(\\rho_A\\) is the density of air, \\(C_{DA}\\) is the wind resistance coefficient, \\(A_{XV}\\) is the area of maximum transverse section exposed to the wind, \\(\\psi_{WREF}\\) relative direction of the wind, \\(V_{WREF}\\) relative wind speed, and \\(V_G\\) is the speed over ground.\nThe formula calculates resistance experienced by the ship when there is no wind and all resistance comes from the movement of the ship itself. This value is then subtracted from the wind resistance experienced by the ship during the trial. Put this way it is clear that the equation finds the difference between the wind resistance on a still day and on the day of the trial.\n\n\n\n\n\n\nNote\n\n\n\nThe ITTC manual notes that values of \\(C_{DA}(x)\\) from the tables in load_wind_coefficients need to be reversed when enetering into the wind resistance formula, that is \\(C_{DA}= -C_x\\). For consistancy the same must be done here\n\n\nITTC equations: 9\n\nsource\n\n0.4.1 wind_resistance\n\n wind_resistance (air_density:float, wind_resistance_coef_rel:float,\n                  wind_resistance_coef_zero:float, area:float,\n                  relative_wind_speed:float, sog:float)\n\nCalculates the air resistance. N.B. SI units must be used. Do not use knots\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nair_density\nfloat\nAir density [kg/\\(m\\^3\\)]\n\n\nwind_resistance_coef_rel\nfloat\nthe coefficient of wind resistance using the relative angle of the wind\n\n\nwind_resistance_coef_zero\nfloat\nthe coefficient of wind resistance using angle 0 radians\n\n\narea\nfloat\nThe maximum transverse area of the ship exposed to the wind [m^2]\n\n\nrelative_wind_speed\nfloat\nRelative wind speed [m/s]\n\n\nsog\nfloat\nspeed over ground [m/s]\n\n\nReturns\nfloat\nAir resistance [N]\n\n\n\nWhat is the air resistance experienced by a cruise ferry with a tranverse area of 500\\(m^2\\) travelling at 20 knots with a relative wind of 10 knots and a relative wind angle of \\(45^\\circ\\)\n\nsog_ms = knots_to_ms(20)\nwind_speed_ms = knots_to_ms(10)\n\nwind_resistance(1.2, 0.34, 0.69, 500, wind_speed_ms, sog_ms)\n\n-19213.8238090769",
    "crumbs": [
      "General Functions"
    ]
  },
  {
    "objectID": "general_functions.html#resistance-due-to-water-temperature-and-salinity",
    "href": "general_functions.html#resistance-due-to-water-temperature-and-salinity",
    "title": "General Functions",
    "section": "0.5 Resistance due to water temperature and salinity",
    "text": "0.5 Resistance due to water temperature and salinity\nThe temperature and salt content of the water affect its density. As such, they also affect the ship resistance.\n\\[R_{AS} = R_{T0}  \\left( \\frac{\\rho_S}{\\rho_0} -1  \\right) - R_F \\left( \\frac{C_{F0} + \\Delta C_{F0}}{C_{F} + \\Delta C_{F}} -1\\right)\\]\nand\n$R_F = _S S V_S^2 (C_F + C_F) $\n$R_{F0} = 0 S V_S^2 (C{F0} + C_{F0}) $\n$R_{T0} = 0 S V_S^2 C{T0} $\nThe below function taken from section 10.3.3 of the ITTC corrects the sea water temperature, and salt content to be that of the appropriate reference values.\n\n\n\nvariable\nreference value\n\n\n\n\ntemperature\n\\(15^\\circ \\text{C}\\)\n\n\nDensity\n1026\\(kg/m^3\\)\n\n\n\nThe coefficients of roughness used in the function are derived from ITTC Recommended Procedures 7.5-02-03-01.4\nThe values of CF and CF0 can be obtained using the CF_fn function. The values of delta_CF and delta_CF0 and be found using the roughness_allowance_fn\nITTC equations: 14 to 17\n\nsource\n\n0.5.1 temp_salinity_water_resistance\n\n temp_salinity_water_resistance (CF:float, CF0:float, delta_CF:float,\n                                 delta_CF0:float, CT0:float, S:float,\n                                 stw:float, rho_S:float, rho_0:float=1026)\n\nResistance due to water temperature and salinity corrected relative to the reference values\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nCF\nfloat\n\nfrictional resistance coefficient for actual water temperature and salinity\n\n\nCF0\nfloat\n\nfrictional resistance coefficient for reference water temperature and salinity\n\n\ndelta_CF\nfloat\n\nroughness allowance associated with Reynolds number for actual water temperature and salinity\n\n\ndelta_CF0\nfloat\n\nroughness allowance associated with Reynolds number for reference water temperature and salinity\n\n\nCT0\nfloat\n\ntotal resistance coefficient for reference water temperature and salinity\n\n\nS\nfloat\n\nwetted surface area [m2]\n\n\nstw\nfloat\n\nship’s speed through the water [m/s]\n\n\nrho_S\nfloat\n\nwater density for actual water temperature and salt content [kg/m3 ]\n\n\nrho_0\nfloat\n1026\nwater density for reference water temperature and salt content\n\n\nReturns\nfloat\n\nresistance increase due to deviation of water temperature and water density [N]\n\n\n\nI have absolutely no idea what sensible values should look like, so this function will need to wait for beta testing, before the documentation can be complete\nAlso this function will probably need to point to some other functions for calculating the roughness coefficents.\n\ntemp_salinity_water_resistance(CF = 1.501e-3, CF0 = 1.5e-3, delta_CF = 2.12e-4, delta_CF0 = 2.1e-4, \n                               CT0 = 1.4e-3, S = 8000, stw = 10, rho_S = 1025, rho_0 = 1026)\n\n669.9999999998915",
    "crumbs": [
      "General Functions"
    ]
  },
  {
    "objectID": "general_functions.html#load-example-data",
    "href": "general_functions.html#load-example-data",
    "title": "General Functions",
    "section": "1.1 Load example data",
    "text": "1.1 Load example data\nThere are some example datasets included in this library to help with understanding the process of evaluating seatrials. Loading the data uses the following function\n\nsource\n\n1.1.1 load_datasets\n\n load_datasets (dataset:str)\n\nLoad example datasets to try out the pyseatrials functions\n\n\n\n\nType\nDetails\n\n\n\n\ndataset\nstr\nThe name of the dataset to load\n\n\n\nThe propeller advance dataset contains the propeller advance curve for the coefficient of torque and the coefficient of thrust coefficient for an imaginary ship\n\npropeller_advance_df = load_datasets(\"propeller_advance_lookup\")\npropeller_advance_df\n\n\n\n\n\n\n\n\nJ\nK_T\nK_Q\n\n\n\n\n0\n0.30\n0.300\n0.038\n\n\n1\n0.35\n0.270\n0.036\n\n\n2\n0.40\n0.260\n0.034\n\n\n3\n0.45\n0.240\n0.032\n\n\n4\n0.50\n0.210\n0.030\n\n\n5\n0.55\n0.200\n0.028\n\n\n6\n0.60\n0.195\n0.026\n\n\n7\n0.65\n0.170\n0.023\n\n\n8\n0.70\n0.150\n0.021\n\n\n9\n0.75\n0.130\n0.020\n\n\n10\n0.80\n0.090\n0.016\n\n\n11\n0.85\n0.080\n0.013\n\n\n\n\n\n\n\nPlotting the dataset reveals a simple line from experimental data\n\nimport matplotlib.pyplot as plt\n\n\nplt.plot(propeller_advance_df['J'], propeller_advance_df['K_T'],'b-', lw=1, label='Linear')",
    "crumbs": [
      "General Functions"
    ]
  },
  {
    "objectID": "wind.html",
    "href": "wind.html",
    "title": "Evaluation of wind data (wind)",
    "section": "",
    "text": "Equations in this section are the equivalent to the equations in appendix E of ITTC. However, mostly the functions here are a wrapper over the functions found in the trig module\nRemember that windspeed is ALWAYS positive, the direction tells you if it is helping or hindering the ship. Negative wind speeds are positive windspeeds rotated \\(180^\\circ\\).\nUnderstanding wind directions and speeds, aswell as their conversion into relative and true forms can be confusing, the below figures aim to clarify how this works",
    "crumbs": [
      "Evaluation of wind data (wind)"
    ]
  },
  {
    "objectID": "wind.html#true-wind",
    "href": "wind.html#true-wind",
    "title": "Evaluation of wind data (wind)",
    "section": "1 True Wind",
    "text": "1 True Wind\nThe two functions in this section convert relative wind speed and direction to thier True equivalents.\n\n1.1 Speed\nCalculating true windspeed from relative windspeed and direction\n\\[V_\\textrm{WR} = \\sqrt{V_{WR}^2 + V_G^2 - 2V_{WR} V_G \\cos(\\psi_{WR})}\\]\nITTC equations: E-2\n\nsource\n\n\n1.2 rel2true_speed\n\n rel2true_speed (relative_windspeed:float, sog:float,\n                 relative_wind_direction:float)\n\nconverts a relative wind speed and direction to a true wind speed\n\n\n\n\nType\nDetails\n\n\n\n\nrelative_windspeed\nfloat\nspeed of wind relative to ship\n\n\nsog\nfloat\nspeed over ground\n\n\nrelative_wind_direction\nfloat\nwind direction relative to ship\n\n\nReturns\nfloat\nTrue windspeed\n\n\n\nIf the wind is blowing has a relative angle of 0, (meaning the wind is blowing from the bow to the stern) and has a relative windspeed of 2 knots, then the true windspeed can be calculated as\n\nrel2true_speed(2, 20, 0)\n\n18.0\n\n\nConversely if the wind is blowing from stern to bow this means the true windspeed is 22\n\nrel2true_speed(2, 20, np.pi)\n\n22.0\n\n\nHowever if the relative angle is \\(-45^\\circ\\) then the true windspeed is\n\nrel2true_speed(2, 20, -np.pi/4)\n\n18.63951333874026\n\n\nRemember that windspeed is ALWAYS positive, the direction tells you if it is helping or hindering the ship\n\n\n1.3 Direction\nHow to calculate the true direction from the relative direction.\n$$ _ = ( )\n$$\nITTC equations: E-3\n\nsource\n\n\n1.4 rel2true_dir\n\n rel2true_dir (relative_wind_speed:float, sog:float,\n               relative_wind_direction:float, vessel_heading:float,\n               constrain_to_positive:bool=True)\n\nconverts relative wind direction to true wind direction\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nrelative_wind_speed\nfloat\n\nSpeed of the wind relative to the ship\n\n\nsog\nfloat\n\nSpeed of the ship overground\n\n\nrelative_wind_direction\nfloat\n\ndirection of wind in radians relative to the ship\n\n\nvessel_heading\nfloat\n\nThe direction of the ship through the water\n\n\nconstrain_to_positive\nbool\nTrue\nShould the function return a value between 0 and 2 pi\n\n\nReturns\nfloat\n\nthe true wind directionangle relative to north in radians.\n\n\n\nConsidering a ship where the relative wind direction is 0, the relative windspeed is 2, and the ships heading is \\(45^\\circ\\) or \\(\\frac{\\pi}{2}\\), then the true wind speed is\n\nrel2true_dir(2,20,0,2)\n\n5.141592653589793\n\n\nAlthough by default the wind direction is constrained to return only positive values between \\(0\\) and \\(2\\pi\\), values between \\(-\\frac{\\pi}{2}\\) and \\(\\frac{\\pi}{2}\\), can be created using constrain_to_positive = False\n\nrel2true_dir(2,20,0,2, False)\n\n-1.1415926535897933\n\n\n\n#### bug alert!\n#does this make sense?\n#should it be 180 or zero?\nrel2true_dir(2,20,0,0, False)\n\n3.141592653589793",
    "crumbs": [
      "Evaluation of wind data (wind)"
    ]
  },
  {
    "objectID": "wind.html#relative-wind",
    "href": "wind.html#relative-wind",
    "title": "Evaluation of wind data (wind)",
    "section": "2 Relative Wind",
    "text": "2 Relative Wind\n\n2.1 Speed\nCalculating relative wind speed from true wind speed and direction as shown in the equation below\n\\[V_\\textrm{WR} = \\sqrt{V_{TW}^2 + V_G^2 + 2V_{TW} V_G \\cos(\\psi_{WT} - \\psi)}\\]\nITTC equations: E-7, E-10\n\nsource\n\n\n2.2 true2rel_speed\n\n true2rel_speed (true_wind_speed:float, sog:float,\n                 true_wind_direction:float, vessel_heading:float)\n\nconverts true windspeed to relative\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntrue_wind_speed\nfloat\nThe windspeed over ground\n\n\nsog\nfloat\nSpeed over ground of the vessel\n\n\ntrue_wind_direction\nfloat\nDirection of wind relative to north\n\n\nvessel_heading\nfloat\nDirection of vessel in water relative to north\n\n\nReturns\nfloat\nreturns relative windspeed using the same units entered\n\n\n\nAs an example consider a ship travelling at 20 knots with a direction due north. The wind blows due north with a speed of 22 knots\n\ntrue2rel_speed(22,20, 0,0)\n\n42.0\n\n\n\ntrue2rel_speed(22,20, 0, np.pi)\n\n2.0\n\n\n\n\n2.3 Direction\nCaclulating relative windspeed from true windspeed and direction\n\\[\\psi_\\textrm{WR} = \\text{arctan2}\\left( \\frac{ V_\\textrm{WT} \\textrm{sin}(\\psi_\\textrm{WT} - \\psi)}{ V_\\textrm{G} + V_\\textrm{WT} \\textrm{cos}(\\psi_\\textrm{WT} - \\psi)} \\right)\\]\nITTC equations: E-6, E-9\n\nsource\n\n\n2.4 true2rel_dir\n\n true2rel_dir (true_wind_speed:float, sog:float,\n               true_wind_direction:float, vessel_heading:float,\n               constrain_to_positive:bool=True)\n\nconverts true direction speed to relative\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntrue_wind_speed\nfloat\n\nThe windspeed over ground\n\n\nsog\nfloat\n\nSpeed over ground of the vessel\n\n\ntrue_wind_direction\nfloat\n\nDirection of wind relative to north\n\n\nvessel_heading\nfloat\n\nDirection of vessel in water relative to north\n\n\nconstrain_to_positive\nbool\nTrue\nShould the function return a value between 0 and 2 pi\n\n\nReturns\nfloat\n\nrelative wind direction\n\n\n\nWe can see that if a ship is heading due north and the true windspeed is also due east. When the ship is at 20 knots and the wind is at 22 knots, the relative direction of the wind is as below\n\ntrue2rel_dir(22,20, np.pi/2,0, constrain_to_positive=False)\n\n0.8329812666744317\n\n\nIf the wind direction is due west, the relative wind direction is the negative of the previous value\n\ntrue2rel_dir(22,20, -np.pi/2,0, constrain_to_positive=False)\n\n-0.8329812666744317\n\n\nUnless of course ‘constrain_to_positive’ is set to true\n\ntrue2rel_dir(22,20, -np.pi/2,0, constrain_to_positive=True)\n\n5.450204040505154",
    "crumbs": [
      "Evaluation of wind data (wind)"
    ]
  },
  {
    "objectID": "wind.html#average-wind-speed-and-direction-across-a-double-run",
    "href": "wind.html#average-wind-speed-and-direction-across-a-double-run",
    "title": "Evaluation of wind data (wind)",
    "section": "3 Average wind speed and direction across a double run",
    "text": "3 Average wind speed and direction across a double run\nThe ITTC method proposes taking the average windspeed across a double run to average for errors in readings This function is a wrapper round the ‘combine_vectors’ function from the trig module. \\[c \\; \\text{cos}(\\gamma) = a \\; \\text{cos}(\\alpha) + b \\; \\text{cos}(\\beta), \\] \\[c \\; \\text{sin}(\\gamma) = a \\; \\text{sin}(\\alpha) + b \\; \\text{sin}(\\beta), \\]\n\\[c = \\sqrt{(\\frac{c \\; \\text{cos}(\\gamma)^2 + c \\; \\text{sin}(\\gamma)^2}{2})} \\]\n\\[\\gamma = \\text{arctan2} \\left( \\frac{c \\; \\text{cos}(\\gamma)}{c \\; \\text{sin}(\\gamma)} \\right)\\]\nWhere \\(a\\) and \\(b\\) are the true windspeeds of two paired runs and \\(\\alpha\\) and \\(\\beta\\) are there true direction.\nThe function takes the magnitude and angle of two vectors and outputs the magnitude and angle of the resultant vector.\nOne can question whether this approach makes physical sense under certain conditions, the user should consider what is happening in the test and consult the reasoning of the ITTC for further details.\nITTC equations: E-4, E-5\n\nsource\n\n3.1 double_run_average\n\n double_run_average (a, b, alpha, beta)\n\nIn the example below on the first run a ship is faced with a wind of 13m/s blowing from the north, whilst on the second run the wind has dropped to 5m/s and is coming from the east. The function calculates the mean wind speed across both runs.\n\nwind_speed, wind_direction = double_run_average(a = 13, b = 5, alpha = 0, beta = 1.6)\n\nprint(\"The wind speed is {0} m/s, the wind direction is {1} radians\".format(round(wind_speed, 2), round(wind_direction, 2)))\n\nThe wind speed is 6.9 m/s, the wind direction is 0.37 radians",
    "crumbs": [
      "Evaluation of wind data (wind)"
    ]
  },
  {
    "objectID": "wind.html#correcting-for-the-height-of-the-anemometer",
    "href": "wind.html#correcting-for-the-height-of-the-anemometer",
    "title": "Evaluation of wind data (wind)",
    "section": "4 Correcting for the height of the Anemometer",
    "text": "4 Correcting for the height of the Anemometer\nAdjusts the windspeed taking into account the height of the anemometer on the ship relative to the reference height for windspeed\n\\[V_\\textrm{WTref} = V_\\textrm{WT} \\left( \\frac{Z_\\textrm{ref}}{Z_a} \\right)^\\frac{1}{9}\\]\nITTC equations: E-8\n\nsource\n\n4.1 vertical_position_anemometer\n\n vertical_position_anemometer (true_wind_speed:float,\n                               reference_height:float,\n                               measured_height:float)\n\nAdjusts the windspeed taking into account the height of the anemometer on the ship relative to the reference height for windspeed\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntrue_wind_speed\nfloat\nTrue windspeed [m/s]\n\n\nreference_height\nfloat\nreference height [m]\n\n\nmeasured_height\nfloat\nmeasured height [m]\n\n\nReturns\nfloat\nThe true windspeed corrected for measurement height\n\n\n\nThe adjusted wind speed differences are often small but the corrections can still influence the final result\n\nvertical_position_anemometer(22,5, 10)\n\n20.36924367032039",
    "crumbs": [
      "Evaluation of wind data (wind)"
    ]
  },
  {
    "objectID": "current.html",
    "href": "current.html",
    "title": "Current Correction (current)",
    "section": "",
    "text": "This module represents the Appendix H of the ITTC, and provides the functionality to correct for current.\nThe current correction approaches can only really be used if the ITTC speed power process has been followed closely. The corrections require that there are multiple runs for several speed settings. This allows a regression to be made. If there is only one speed setting then the methods described in appendix H will not be applicable. If multiple double runs or runs at different speeds have not been performed then ship current sensors, met-ocean data, or other methods will have to be used.",
    "crumbs": [
      "Current Correction (current)"
    ]
  },
  {
    "objectID": "current.html#which-to-choose",
    "href": "current.html#which-to-choose",
    "title": "Current Correction (current)",
    "section": "1 Which to choose?",
    "text": "1 Which to choose?\nAlthough the two methods are not mutually exlusive, they do have different minimum data gathering requirements in order to be used.\n\nThe iterative method can be used when the seatrial has performed a SINGLE set of double runs at DIFFERENT power settings\nThe Mean of Means method can be performed when there have been TWO sets of double-runs at the SAME power setting",
    "crumbs": [
      "Current Correction (current)"
    ]
  },
  {
    "objectID": "current.html#iterative-method",
    "href": "current.html#iterative-method",
    "title": "Current Correction (current)",
    "section": "2 Iterative Method",
    "text": "2 Iterative Method\nThe iterative method assumes a current that varies with a semidurational period. This period is typically 12 hours, 25 minutes and 12 seconds, which can also be described as 0.51753 of a day. The function can use any speed unit and any unit of power although, the original ITTC documentation uses Knots and kWh respectively.\nThe process for estimating the current and the true speed through water is described below.\n\n2.1 Step 1: Estimate the speed-power curve\nUsing the known speed over ground (\\(V_g\\)) values and observed power (\\(P_{obs}(V_s)\\)) values for each power/speed setting, find the coefficients of the equation\n\\[P(V_s) =a+ bV_s^q\\]\nWhere:\n\nP(V_s) = the engine power at speed V_s\na,b, q = unknown coefficients\n\n\n\n2.2 Step 2: Estimate speed through water from observed power and speed-power model\nusing the coefficients of the speed power mode and the observed power calculate and estimate of the necessary speed through water using\n\\[V_s = \\sqrt[q]{\\frac{P(V_s)-a}{b}}\\]\n\n\n2.3 Step 3: Estimate Current and current coefficients\nUsing \\(V_c = V_G - V_s\\), get an estimate of \\(V_c\\) for each speed setting and use it to find the coefficients of the following equation using leasts-squares\n\\[V_c = V_{C,C}\\textrm{cos}(\\frac{2\\pi}{T_c}t) + V_{C,S}\\textrm{sin}(\\frac{2\\pi}{T_c}t) + V_{C,T}t + V_{C,0}\\]\nWhere:\n\nV_c = the current speed in knots\nT_c = is the period of variation of current speed, it is measured in hours\nt = the time for each run relative to the first run, it is measured in hours.\n\\(V_{C,C}, V_{C,S}, V_{C,T}, V_{C,0} =\\) are unknown factors which found through iteration\n\nOnce the coefficients have been calculated the value of \\(V_c\\) can be updated\n\n\n2.4 Step 4: Re-calculate the speed-power curve coefficients\nUsing the updated value of \\(V_c\\) update the value of \\(V_s\\) and re-calculate the parameters a.b and q for the speed power curve.\nUsing the new speed power curve and the estimated values of \\(V_s\\) create the predicted values of engine power.\n\n\n2.5 Step 5: Measure the error between the observed and predicted Enginer power\nUsing the equation\n\\[SSE =\\sum (P_{pred}(V_s)-P_{obs}(V_s))^2\\]\nmeasure the sum square error of the estimates. if the error is larger than tolerance go to Step 2, otherwise if the process has converged and the error minimised, finish and return the final values of \\(V_c\\) and \\(V_s\\)\nWhen setting the tolerance any small value is acceptable. typically a tolerance of \\(10^{-6}\\) is used however values as large as \\(10^{-2}\\) would probably have negligable impact on the final analysis\n\n\n2.6 Diagram\nThe below diagram provides a schematic of the process described above\n\n\n\n\n\ngraph LR;\n  A(SOG) --&gt; B(Step 1)\n  Z(Power) --&gt;B\n  B --&gt; C(Step 2)\n  C --&gt; D(Step 3)\n  D --&gt; E(Step 4)\n  E --&gt; L{Convergence?}\n  L -- No --&gt; C\n  L -- Yes --&gt; M[Return STW]\n\n\n\n\n\n\n\n\n2.7 Note:\nThis algorithm is not guarenteed to converge, nor is it guarenteed to reduce the square error each iteration. As such the function returns the current and power law parameters which produced the lowest error. It also returns a dataframe containing the error for each iteration\nITTC equations: H-1 to H-5\nThis equation is not vectorised\n\nsource\n\n\n2.8 estimate_speed_through_water\n\n estimate_speed_through_water (power:float, sog:float, t:float, T_c:float,\n                               tolerance:float=1, max_iter:float=1000,\n                               p0:list=[0, 1, 3], bounds:tuple=([0, 0,\n                               2.5], [5000, 20, 3.5]))\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npower\nfloat\n\nThe engine power, typically the ‘ideal condition’ is used [W]\n\n\nsog\nfloat\n\nSpeed over ground of the vessel [m/s]\n\n\nt\nfloat\n\nTime difference from current run to first run [hours]\n\n\nT_c\nfloat\n\nTime duration period of the tide typically 12.42 hours [hours]\n\n\ntolerance\nfloat\n1\nThe process terminates when the error falls below the specified threshold in Watts\n\n\nmax_iter\nfloat\n1000\nMax imum number of iterations before process terminates\n\n\np0\nlist\n[0, 1, 3]\nthe initial guess for the power law coefficients they represent the expeonents a + bX^c [None]\n\n\nbounds\ntuple\n([0, 0, 2.5], [5000, 20, 3.5])\nBounds the power law equation to within realistic values\n\n\nReturns\ntuple\n\nOutputs a tuple of the stw, current, current coefficients, and speed power coefficints that minimised the error. Also returns a dataframe or the error per iteration\n\n\n\nTo help gain an intuitive understanding of the concept of the semidiurnal current, an example is plotted below. Not that the last terms in the current model (i.e. ‘\\(V_{C,T}t + V_{C,0}\\)’) has no periodic component. This means that the iterative method can produce increasingly incorrect results over longer periods.\n\nT_c = 12\nV_c_C=-2\nV_c_S=-2\nV_c_T=0.1\nV_c_0=0.1\n\ntimes = np.linspace(0, 24, 200)\ncurrent_speed = V_c_C * np.cos((2 * np.pi / T_c) * times) + V_c_S * np.sin((2 * np.pi / T_c) * times) + V_c_T * times + V_c_0\n\nplt.plot(times, current_speed)\nplt.xlabel('Time (hours)')\nplt.ylabel('Current speed')\nplt.title('Current speed over 24 hours using the iterative method')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nThe example below demonstrates the process of identifying current speed using speed overground and the current equation. It should be noted that this method is an estimate only and as can be seen by the example can still produce a significant error.\n\nT_c = 12\nV_c_C=-2\nV_c_S=-2\nV_c_T=0.1\nV_c_0=0.1\n\nt = np.array([0, 1, 2, 3, 4])  # Time values relative to the first run\nsog = np.array([5, 10, 15, 20, 25])\nV_c_true = V_c_C * np.cos((2 * np.pi / T_c) * t) + V_c_S * np.sin((2 * np.pi / T_c) * t) + V_c_T * t + V_c_0\nV_s_true = V_c_true + sog\na_true = 2\nb_true = 3\nc_true = 3\npower = a_true + b_true * V_s_true ** c_true\n\n\nstw, current_speed, _, _, error_df = estimate_speed_through_water(power, sog, t, T_c)\nprint(\"Estimated speed through water:\", stw)\n\nprint(\"The error on the estimated speed through water is: \"+str(stw-V_s_true) )\n\n\nplt.plot(t, V_s_true)\nplt.scatter(t, stw, color = 'red')\n\nplt.xlabel('Time (hours)')\nplt.ylabel('Speed Through Water')\nplt.title('True STW (blue) and estimated STW (red)')\nplt.grid(True)\nplt.show()\n\nEstimated speed through water: [ 3.36403099  7.8889879  13.11458325 19.03103214 25.44343601]\nThe error on the estimated speed through water is: [0.26403099 0.42103871 0.54663406 0.63103214 0.67548682]\n\n\n\n\n\n\n\n\n\nThe error on the calculation can also be visualised.\n\nplt.plot(error_df['Iteration'], error_df['Power_Error'])\nplt.xlabel('Iteration')\nplt.ylabel('Sum of squared errors')\nplt.title('Change in error per iteration')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "Current Correction (current)"
    ]
  },
  {
    "objectID": "current.html#mean-of-means-method",
    "href": "current.html#mean-of-means-method",
    "title": "Current Correction (current)",
    "section": "3 Mean of means method",
    "text": "3 Mean of means method\nAnother approach to finding the current\n\\[V_s = \\frac{V_{G1} + 3V_{G2}+ 3V_{G3} + V_{G4}}{8}\\]\nWhere \\(V_s\\) is the speed through water and \\(V_{G1}\\) to \\(V_{G4}\\) are the mean speed over-ground for each double run at a given speed.\nThe current is assumed to have a parabolic form and as such can be expressed as\n\\[V_c = V_{C,2} t^2 + V_{C,1} t +V_{C,1}\\]\nWhere \\(V_c\\) is the current speed, and \\(V_{C,2}\\), \\(V_{C,1}\\), \\(V_{C,0}\\) are unknown factors.\nThe solution to the current equation can therefore be found by treating it as a system of linear equations of the form \\(y = X\\beta\\). The system of linear equations is shown below.\n\\[\\begin{bmatrix}\n    V_{G1} - V_s  \\\\\n    V_{G2} - V_s  \\\\\n    V_{G3} - V_s \\\\\n    V_{G4} - V_s  \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n    (t + 3\\Delta t)^2 & -(t + 3\\Delta t) & 1 \\\\\n    (t + \\Delta t)^2 & -(t + \\Delta t) & 1 \\\\\n    (t - \\Delta t)^2 & -(t - \\Delta t) & 1 \\\\\n    (t - 3\\Delta t)^2 & -(t - 3\\Delta t) & 1 \\\\\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n    V_{C,2}\\\\\n    V_{C,1} \\\\\n    V_{C,0} \\\\\n\\end{bmatrix} \\]\nThis equation demonstrates the need to perform two double runs, i.e. 4 runs as this will result in four equations with the 3 uknowns of \\(V_{C,2}\\), \\(V_{C,1}\\), \\(V_{C,0}\\). It should be noted that as current is not a parabola the values found should be used for interpolation not extrapolation. Setting the example below to 24 hours will produce terrifying torrents, which are obviously not realistic.\nITTC equations: H-6 to H-11\nThis equation is not vectorised\n\nsource\n\n3.1 current_mean_of_means\n\n current_mean_of_means (sog:numpy.ndarray, start_time:float,\n                        time_between_runs:float)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nsog\nndarray\nThe mean speed over ground across a double run,\n\n\nstart_time\nfloat\nTime in decimal hours when the first run took place,\n\n\ntime_between_runs\nfloat\nTime in decimal hours between each run. Note the time difference must be consistent between all runs\n\n\nReturns\nfloat\nOutputs a tuple of the stw vector, the current vector and the coefficients\n\n\n\n\nsog = np.array([10, 12.6, 12.6, 11])  # Mean speed over ground across a double run\nstart_time = 0.0  # Time in decimal hours when the first run took place\ntime_between_runs = 1  # Time in decimal hours between each run\n\nstw, current, coefs= current_mean_of_means(sog, start_time, time_between_runs)\nprint(\"Current speed m/s:\", current)\n\nCurrent speed m/s: [-0.525 -0.405 -0.525 -0.885]\n\n\n\ndef quadratic_function(t, coeffs):\n    a, b, c = coeffs\n    return a * t**2 + b * t + c\n\n# Calculate the current speed throughout the day\ntimes = np.linspace(0, 4, 100)  \ncurrent_strength = quadratic_function(times, coefs) \n\n# Plot the current speed over the 24-hour period\nplt.plot(times, current_strength)\nplt.xlabel('Time (hours)')\nplt.ylabel('Current speed')\nplt.title('Current speed over four hours using the mean of means method')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nimport nbdev; nbdev.nbdev_export()",
    "crumbs": [
      "Current Correction (current)"
    ]
  },
  {
    "objectID": "power.html",
    "href": "power.html",
    "title": "Direct Power Analysis (power)",
    "section": "",
    "text": "The calculating of the power transmitted to the water correcting for environmental conditions is\n\\[P_{Did} = P_{Dms}-\\Delta P,\\] where \\(P_{Dms}\\) is the delivered power in the trial conditions, and \\(\\Delta P\\) is the correction of the delivered power taking into account the resistances and changes in propulsive power as a result of the trial conditions.\nThis section of the pyseatrials library is concerned with deriving the values needed for this calculation\nSome things should come with a bit more clarification e.g. ‘wake-fraction’, what is it?",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#understanding-the-notation",
    "href": "power.html#understanding-the-notation",
    "title": "Direct Power Analysis (power)",
    "section": "1 Understanding the notation",
    "text": "1 Understanding the notation\nThere are severl sub-scripts used in this section which are useful to understand\nThere are four types of upper case letter used which require further explanation\n\nD ‘Delivered’ used to differentiate types of power\nM ‘Model’ used for values taken from a model of the ship in a tank test\nR ‘Relative’ used to differentiate different types of efficiency\nS ‘Full-scale’ used to distinguish from values derived from models\n\nThe lower case abreviations are\n\nid refers to the ‘ideal condition’\nms refers to the ‘trial condition’",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#correction-delivered-power",
    "href": "power.html#correction-delivered-power",
    "title": "Direct Power Analysis (power)",
    "section": "2 Correction delivered power",
    "text": "2 Correction delivered power\nCalculates the power when correcting for the resistances experienced by the vessel as well as the deciation of propeller efficiency relative to ideal\n\\[\\Delta P = \\frac{\\Delta R V_s}{\\eta_{Did}}+ P_{Dms}(1-\\frac{\\eta_{Dms}}{\\eta_{Did}}), \\] where \\(\\Delta R\\) is the total resitance increase experienced by the ship, \\(V_s\\) is the speed through water, \\(\\eta_{Did}\\) is the propulsive efficiency coefficient in the ideal conditions, \\(P_{Dms}\\) is the shaft power during the test,\\(\\eta_{Dms}\\) is the propulsive efficiency coefficient in the trial conditions.\nThe value for \\(\\Delta R\\) is calculated as the some of the wind, wave, and water resistances. The functions for these values are found at wind_resistance, stawave1_fn, and temp_salinity_water_resistance\nITTC equations: J-2\n\nsource\n\n2.1 correction_delivered_power\n\n correction_delivered_power (p_dms:float, resistance_increase:float,\n                             stw:float, eta_id:float, eta_ms:float)\n\ncalculates the corrected delivered power, used as part of the direct power analysis\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\np_dms\nfloat\ndelivered power [W]\n\n\nresistance_increase\nfloat\nResistance increase derived from data measured in seatrial\n\n\nstw\nfloat\nspeed through water [m/s]\n\n\neta_id\nfloat\npropulsive efficiency in the ideal conditions\n\n\neta_ms\nfloat\npropulsive efficiency in the seattrial\n\n\nReturns\nfloat\nReturns the corrected delivered power in Newtons [N]\n\n\n\nExample of using function, generally this is not used directly\n\ncorrection_delivered_power(1e4, 1e3, 10, 0.8, 0.7)\n\n13750.000000000002",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#propulsive-efficiency-correction",
    "href": "power.html#propulsive-efficiency-correction",
    "title": "Direct Power Analysis (power)",
    "section": "3 Propulsive efficiency correction",
    "text": "3 Propulsive efficiency correction\nThis can be used to calculate both the ideal and trial conditions reffered to in equations J-3 and J-5 \\[\\eta_D = \\eta_o \\eta_R \\frac{1-t}{1-w_s} \\]\nITTC equations J-3, J-5\n\nsource\n\n3.1 propulsive_efficiency_corr\n\n propulsive_efficiency_corr (n_o:float, n_r:float, t:float, w_s:float)\n\nCalculates propeller efficiency adjusting for additional resistances\n\n\n\n\nType\nDetails\n\n\n\n\nn_o\nfloat\nopen water efficiency\n\n\nn_r\nfloat\nrelative rotative efficiency\n\n\nt\nfloat\nthrust deduction factor\n\n\nw_s\nfloat\nfull-scale wake fraction\n\n\n\n\npropulsive_efficiency_corr(0.58, 0.7, 0.1, 0.5)\n\n0.7308",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#full-scale-wake-fraction",
    "href": "power.html#full-scale-wake-fraction",
    "title": "Direct Power Analysis (power)",
    "section": "4 Full scale wake fraction",
    "text": "4 Full scale wake fraction\nThere are two different functions related to the full scale wake fraction, both are presented in this sub-section.\nThe two related but distinct values are\n\n\\(w_{S}\\): Full-scale wake fraction using model\n\\(w_{S}\\): Full-scale wake fraction using speed\n\\(e_i\\) Scale correlation factor of the wake faction\n\n\n4.1 The full scale wake fraction\n\\[w_S =  1- (1- w_M)e_i,\\] where \\(W_S\\) is the fullscale wake fraction, \\(W_m\\) is the model wake fraction derived from tank tests, and \\(e_i\\) is the scale correlation factor derived from XXXX derived from what?.\nITTC equation: J-4, J-20\n\nsource\n\n\n4.2 full_scale_wake_fraction\n\n full_scale_wake_fraction (wake_fraction_model:float,\n                           scale_correlation_factor:float)\n\nused to scale from model results to full-scale vessel\nThe full scale wake fracrtion returns a value between 0 and 1\n\nfull_scale_wake_fraction(0.4, 0.8)\n\n0.52\n\n\n\n\n4.3 Full-scale wake fraction from speed\nThis approach calculates the wake fraction using the measured water speeds\n\\[w_S =1- \\frac{V_A}{V_S},\\] where \\(V_A\\) is the speed of flow into the propeller, and \\(V_S\\) is the ship’s speed through water.\nITTC equations: J-17\n\nsource\n\n\n4.4 full_scale_wake_speed\n\n full_scale_wake_speed (flow_speed:float, stw:float)\n\nCalculate the wake fraction using the measured water speeds\n\n\n\n\nType\nDetails\n\n\n\n\nflow_speed\nfloat\nThe speed of flow through the propeller\n\n\nstw\nfloat\nShip’s speed through water\n\n\nReturns\nfloat\n\n\n\n\nThis approach to obtianing the full scale wake speed is typically used for getting the trial conditions\n\nfull_scale_wake_speed(10,50)\n\n0.8\n\n\n\n\n4.5 Scale correlation factor\nThe scale correlation factor is simply the re-arranged fullscale wake fraction. And is shown as\n\\[e_i = \\frac{1-w_S}{1-w_M},\\] where values are the same as previously.\nITTC equation: J-21\n\nsource\n\n\n4.6 scale_correlation_factor\n\n scale_correlation_factor (trial:float, model:float)\n\nCalcualte the scale correlation factor using the model fraction from tank tests, and the full-scale fraction from trials\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntrial\nfloat\nThe full-scale wake fraction in the trial\n\n\nmodel\nfloat\nThe wake fraction of the model derived from tank tests\n\n\nReturns\nfloat\nThe dimensionless coefficient joining the full scale and model fractions\n\n\n\nDeriving the scale correlation factor is easy given the inputs\n\nscale_correlation_factor(0.6,0.8)\n\n2.0000000000000004",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#self-propulsion-factors",
    "href": "power.html#self-propulsion-factors",
    "title": "Direct Power Analysis (power)",
    "section": "5 Self propulsion factors",
    "text": "5 Self propulsion factors\nThis function allows for ship factors to be adjust accounting for the difference between ideal/model conditions and the conditions during the trial. This function is equivalent to equation J-6 to J-8. The function is essentially the following equation\n\\[x_{test} = x_{ideal} + \\Delta x_R (\\frac{\\Delta R}{R_{ideal}}),\\] Where \\(x\\) is the variable to be adjusted \\(x_{ideal}\\) is the value of the variable under ideal conditions, \\(\\Delta x_R\\) the coefficient of of change for each unit of \\(\\frac{\\Delta R}{R_{ideal}}\\), \\(\\Delta R\\) the resistance increase derived from data measured during the sea trial and \\(R_{ideal}\\) is the resistance under ideal conditions. The values of \\(x_{ideal}\\) are obtained from a model test. The value of \\(\\Delta x_R\\) is found by fitting a linear model using data gathered during a specific tank tests. The process of obtaining the value of \\(x_R\\) is described in detail in section J.2.\nIn practice however, these sets of values are not needed as the deviations are often negligable in comparison to the variation of \\(\\eta_O\\). That using \\[ x_{test} \\approx x_{ideal},\\] is acceptable\nITTC equations: J-6, J-7, J-8\n\nsource\n\n5.1 self_propulsion_factors\n\n self_propulsion_factors (x_ideal:float, delta_x:float=0, delta_r:float=1,\n                          delta_r_ideal:float=1)\n\nAdjusting the self propulsion factors is only possible if the required model tests have been performed. By default this function returns the ideal value\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nx_ideal\nfloat\n\nThe variable in ideal conditions. It is acceptable to use this value without adjustments\n\n\ndelta_x\nfloat\n0\nThe change per unit of the resistance ratios. Default is 0\n\n\ndelta_r\nfloat\n1\nincrease in resistance from ideal conditions\n\n\ndelta_r_ideal\nfloat\n1\nResistance in ideal conditions\n\n\nReturns\nfloat\n\n\n\n\n\nGenerally the adjustment for the self propulsion factors will be small. But if available should be applied\n\nself_propulsion_factors(0.8, 0.1, 1000, 10000)\n\n0.81",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#calculate-thrust-coefficient-torque-coefficient-and-load-factor",
    "href": "power.html#calculate-thrust-coefficient-torque-coefficient-and-load-factor",
    "title": "Direct Power Analysis (power)",
    "section": "6 Calculate Thrust coefficient, Torque coefficient, and Load factor",
    "text": "6 Calculate Thrust coefficient, Torque coefficient, and Load factor\nThe thrust coefficient, torque coefficient and the load factor provide useful values for calculating the adjusted propeller efficiency. There are several different approaches. All three approaches are described in this sub-section and are used at various points in the process.\nThe different approaches are\n\nThe inverse quadratic method\nThe quadractic method\nTorque coefficient from water conditions\nLoad factor using propeller advance and thrust\nLoad factor using resistance\n\n\n6.1 The inverse quadratic method\nThe inverse quadratic method doesn’t actually calculate the coefficients themselves but using them as the dependent variable of a quadratic curve where the dependent variable is the propeller advance coefficient in the ideal condition. The result is that the coefficients of the quadratic curve can be either be solved to find the point closest to 0 where the line crosses the x-axis. Alternatively the quadratic coefficients are used replacing the propeller advance coefficients in the ideal condition with those of the trial condition, this creates a quadratic equation that return the thrust coefficient in the trial condition. The propeller advance coefficients in the ideal condition are provided by tank tests, usually 10 data points are supplied in order to fit the curve\n\\[y = aX^2 + bX +c\\]\nThe coefficients of this model (\\(a,b,c\\)) are not useful inthemselves but are input parameters to other functions for example torque_coef\nThe equation is also used to calculate the thrust coefficient in the trial condition/\nITTC equations: J-9, J-10, J-11, J-25, J-26\n\nsource\n\n\n6.2 get_curve_coefficient\n\n get_curve_coefficient (y:float, x:float)\n\nObtain the coefficients used to calculate the Thrus, and Torque coefficients and the load factor coefficients\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ny\nfloat\nAn array containing the dependent variable coefficient\n\n\nx\nfloat\nAn array containing the propeller advance coefficient\n\n\nReturns\nfloat\nReturns an array containing model coefficients\n\n\n\nFor ship whose model tests give a propeller advance coefficient to thrust coefficent \\(K\\) relationship as shown below, we can (back) calculate the coefficients of the quadratic formula using the get_curve_coefficient function.\n\nJ = np.linspace(1,10, 10)\nK = J**2 + 2*J +3 #In reality we obviously do not know the coefficients before hand!\nget_curve_coefficient(K, J)\n\narray([1., 2., 3.])\n\n\nWhen calculating the loading factor coefficients \\(\\tau\\) the values for the propeller advance coefficient needs to be inverted\n\nJ = 1/np.linspace(1,10, 10)\nK = J**2 + 2*J +3 #In reality we obviously do not know the coefficients before hand!\nget_curve_coefficient(K, J)\n\narray([1., 2., 3.])\n\n\n\n\n6.3 The quadratic method\nThe quadratic method assumes you have obtained the coefficients using the inverse quadratic method described previously. This approach simply plugs the value of propeller advance (\\(J\\)) into the equation to return the value of the target coefficients/ factor. This is typically used to calculate the coefficents in the trial condition\n\nsource\n\n\n6.4 quadratic_method\n\n quadratic_method (coefs:float, propeller_advance_coef:float)\n\nCalculate the coefficient using a modelled quadratic curve\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ncoefs\nfloat\nAn array of the coefficients created by the function get_curve_coefficient\n\n\npropeller_advance_coef\nfloat\nThe propeller advance coefficient\n\n\nReturns\nfloat\nThe target value for the coefficient types entered\n\n\n\nThe ITTC use the quadratic method to calculate the thrust coefficient \\(K_{Qms}\\) in the trial condition.\n\nquadratic_method([1,2,3], 2)\n\n11\n\n\n\n\n6.5 Torque coefficient from propeller state\nThe torque coefficient is obtained using\n\\[K_Q = \\frac{P}{2 \\pi \\rho n^3 D^5} \\eta,\\] Where \\(P\\) is power, \\(n\\) is rotations per second, \\(D\\) is shaft diameter and \\(\\eta\\) is relative rotative efficiency.\nGenerally the torque coefficient for the ideal condition is known through tank tests. However, this equation is also used to find the thrust coeficient during the trial. When the trial thrust coefficient is calculated \\(P\\), \\(n\\), and \\(\\eta\\) are all from trial data.\nITTC equations: J-12\n\nsource\n\n\n6.6 torque_coef\n\n torque_coef (power:float, shaft_speed:float, diameter:float,\n              efficiency:float, water_density:float=1026)\n\ncalcualte the torque coefficient under ideal or trial conditions\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npower\nfloat\n\nThe delivered power\n\n\nshaft_speed\nfloat\n\nmeasure propeller shaft speed [rev/s]\n\n\ndiameter\nfloat\n\nproperller_diameter [m]\n\n\nefficiency\nfloat\n\nrelative rotative efficiency\n\n\nwater_density\nfloat\n1026\nwater density [kg/m^3]\n\n\nReturns\nfloat\n\ndimensionless thrust coefficient\n\n\n\nunder trial conditions the thrust coefficient is calculated directly\n\ntorque_coef(1e4, 50, 1.5, 0.8)\n\n1.3073637822066664e-06\n\n\n\n\n6.7 Load factor using propeller advance and thrust\nThe load factor on the propeller can be calculate by\n\\[\\tau_{P} = \\frac{K_{T}}{J^2},\\] where \\(K_{T}\\) is the thrust coefficient and \\(J\\) is the propeller advance coefficient. This approach is usally for finding \\(\\tau_{P}\\) the trial condition\nITTC equations: J-18\n\nsource\n\n\n6.8 load_factor\n\n load_factor (thrust_coefficient:float, propeller_advance:float)\n\nCalculate the load factor using the thrust and propeller advance coefficients\n\n\n\n\nType\nDetails\n\n\n\n\nthrust_coefficient\nfloat\nThe thrust coefficient\n\n\npropeller_advance\nfloat\nThe propeller advance coefficient\n\n\nReturns\nfloat\ndimensionless load factor\n\n\n\nThe load factor on the propeller for the given ship conditions is a key element to calculating the corrected power delivered\n\nload_factor(0.8, 5)\n\n0.032\n\n\n\n\n6.9 Load factor using resistance and propellor state\nThis approach to calculating the loading factors are \\[ \\tau = \\frac{R}{(1- t)(1-w_S)^2 \\rho V^2_S D^2},\\] where \\(R\\) is the total resistance, \\(t\\) is the thrust deduction factor, \\(w_S4\\) is the full-scale wake fraction, \\(\\rho\\) is the water density, \\(V_S\\) is the ship speed through water, and \\(D\\) is the diameter of the propeller. This equation is the same as total_resistance but re-arranged to find \\(\\tau\\).\nITTC equations: J-23\n\nsource\n\n\n6.10 load_factor_resistance\n\n load_factor_resistance (resistance:float, thrust_deduction:float,\n                         wake_fraction:float, stw:float, diameter:float,\n                         water_density:float=1026)\n\nCalculate the load factor of the propeller. Usually used to find the load factor in the ideal condition\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nresistance\nfloat\n\nThe total resistance experienced by the vessel\n\n\nthrust_deduction\nfloat\n\nThe thrust deduction factor\n\n\nwake_fraction\nfloat\n\nThe full-scale wake fraction\n\n\nstw\nfloat\n\nShips speed through water [m/s]\n\n\ndiameter\nfloat\n\nThe diameter of the ships propeller\n\n\nwater_density\nfloat\n1026\ndensity of water in the given conditions [kg/m^3]\n\n\nReturns\nfloat\n\nthis value can be in the ideal condition or trial depending on parameters used\n\n\n\nThe load factor using resistance allow the load factor in the ideal condition to be calculated using only basic information\n\nload_factor_resistance(1e4, 0.7, 0.8, 10, 2.3, 1026)\n\n1.5353794413921111",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#trial-propeller-advance",
    "href": "power.html#trial-propeller-advance",
    "title": "Direct Power Analysis (power)",
    "section": "7 Trial propeller advance",
    "text": "7 Trial propeller advance\nThe propeller advance coefficient for the trial conditions can be calculated by factorising the coefficients of the quadratic curve founs using get_curve_coefficient. The factorisation is the standard quadratic method using\n\\[J = \\frac{-b - \\sqrt{b^2 -4a(c - K_Q)}}{2a},\\] or \\[J = \\frac{-b - \\sqrt{b^2 -4(a- \\tau)c}}{2(a- \\tau)},\\] where \\(a,b,\\) and \\(c\\) are the ouput coefficients from get_curve_coefficient and \\(K_Q\\) is the torque coefficient calculated using torque_coef, and \\(\\tau\\) is the load factor. Note that the propeller advance is only the negative part of the quadratic equation as properller advance must always be positive. This equation is used to derive the propeller advance coefficient from empirical measurements.\nITTC equations: J-13, J-24\n\nsource\n\n7.1 propeller_advance_coefficient\n\n propeller_advance_coefficient (propeller_value:float, a:float, b:float,\n                                c:float, mode:str)\n\nCalculate the propeller advance coefficient using a quadratic curve\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npropeller_value\nfloat\nThe torque coefficient or loading factor as appropriate\n\n\na\nfloat\ncoefficient ‘a’ from get_curve_coefficient\n\n\nb\nfloat\ncoefficient ‘b’ from get_curve_coefficient\n\n\nc\nfloat\ncoefficient ‘c’ from get_curve_coefficient\n\n\nmode\nstr\nDoes function use torque or load mode?\n\n\nReturns\nfloat\n\n\n\n\nThe propeller advance can then be calcualted by combining outputs of the previous functions get_curve_coefficient and torque_coef as inputs to propeller_advance_coefficient.\n\n#These values are obviously not realistic\nJ = np.linspace(1,10, 10)\nK = 2*J**2 + -5*J +3 #In reality we obviously do not know the coefficients before hand!\ncurve_coefs = get_curve_coefficient(K, J)\ntrial_torque_coef = torque_coef(1e4, 50, 1.5, 0.8)\npropeller_advance_coefficient(trial_torque_coef, curve_coefs[0], curve_coefs[1], curve_coefs[2], mode ='torque'  )\n\n0.9999986926396782\n\n\nRemember when calulating the propeller advance using load factors the coefficients used are not those from the load quadratic method but from Thrust\n\n#when I have some example data show that thrust is used not torque\n\npropeller_advance_coefficient(trial_torque_coef, curve_coefs[0], curve_coefs[1], curve_coefs[2], mode ='load'  )\n\n0.9999986926430968\n\n\n\npropeller_advance_coefficient(0, 2, -5, 3, mode = \"load\" )\n\n1.0",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#open-water-efficiency",
    "href": "power.html#open-water-efficiency",
    "title": "Direct Power Analysis (power)",
    "section": "8 Open water efficiency",
    "text": "8 Open water efficiency\nThe efficiency of the properller in open water can be calcualted using\n\\[\\eta_O = \\frac{J}{2 \\pi}\\frac{K_T}{K_Q},\\] where J is the propeller advance coefficient, \\(K_T\\) is the thrust coefficient, and \\(K_Q\\) is the torque coefficient. It can be used for calulating both the trial conditions, but is typically used for trial conditions as the ideal conditions are known from tank tests.\nITTC equations: J-15, J-27\n\nsource\n\n8.1 open_water_efficiency\n\n open_water_efficiency (propeller_advance_coef:float, thrust_coef:float,\n                        torque_coef:float)\n\nCalculate the open water propeller efficiency\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npropeller_advance_coef\nfloat\nThe propeller advance coefficient of the ship\n\n\nthrust_coef\nfloat\nthrust coefficient\n\n\ntorque_coef\nfloat\n\n\n\nReturns\nfloat\n\n\n\n\nThe proppeller open water efficiency for a ship with a propeller advance coefficent of 5, thrust coefficent of 0.8 and torque coefficient of 0.9. Is shown below\n\nopen_water_efficiency(5, 0.8, 0.9)\n\n0.707355302630646",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#speed-of-flow-into-the-propeller",
    "href": "power.html#speed-of-flow-into-the-propeller",
    "title": "Direct Power Analysis (power)",
    "section": "9 Speed of flow into the propeller",
    "text": "9 Speed of flow into the propeller\nThe rate at which water flows past the propeller is given by\n\\[V_A = JnD,\\] where \\(J\\) is the propeller advance coefficient, \\(n\\) is the rotations per second, and \\(D\\) is the diameter of the propeller. When calculating the speed under trial conditions the propeller advance coefficieant can be found using propeller_advance_coefficient\nITTC equations: J-16\n\nsource\n\n9.1 propeller_flow\n\n propeller_flow (propeller_advance_coef:float, rotations_sec:float,\n                 diameter:float)\n\nCalculate speed of water flow into the propeller\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npropeller_advance_coef\nfloat\nPropeller advance coefficient [n/a]\n\n\nrotations_sec\nfloat\npropeller rotations per second [rev/sec]\n\n\ndiameter\nfloat\nDiamter of the propeller [m]\n\n\nReturns\nfloat\nThe value that comes out is in m3/s WHAT ARE THE UNITS?\n\n\n\nreally the propeller advance coefficient function is just a simple wrapper around the product of three values\n\npropeller_flow(5, 30, 2)\n\n300",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#total-resistance",
    "href": "power.html#total-resistance",
    "title": "Direct Power Analysis (power)",
    "section": "10 Total Resistance",
    "text": "10 Total Resistance\nThe total resistance (R) encountered by a ship system can be calculated using the following formula:\n\\[R = \\tau(1- t)(1-w_S)^2 \\rho V^2_S D^2,\\] where \\(\\tau\\) is the loading factor, \\(t\\) is the thrust deduction factor, \\(w_S4\\) is the full-scale wake fraction, \\(\\rho\\) is the water density, \\(V_S\\) is the ship speed through water, and \\(D\\) is the diameter of the propeller. This equation is typically used to calculate the resistance in the trial conditions and is the same as load_factor_resistance but rearranged to get \\(R\\). It should be noted that the equation is analogous to calculating propeller thrust under stable conditions, as such the equation assumes a single propeller. In cases where multiple identical propellers are present, the total resistance can be calculated as follows: \\(R = \\sum_1^m R_i = R_i * m\\), where \\(R_i\\) is the total resistance of a single propeller and \\(m\\) is the total number of propellers (usually two)\nThe total resistance in the trial conditions is used to calculate the resistance in the ideal conditions, using the following formula.\\[R_{id} = R_{ms} - \\Delta R,\\] where \\(R_{ms}\\) is the resistance in the trial conditions, \\(\\Delta R\\) is the resistance created by the wind, wave, and water.\nITTC equations: J-19\n\nsource\n\n10.1 total_resistance\n\n total_resistance (load_factor:float, thrust_deduction:float,\n                   wake_fraction:float, stw:float, diameter:float,\n                   water_density:float=1026)\n\nCalculate the total resistance of the ship. Used to find the resistance in the ideal condition\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nload_factor\nfloat\n\nThe load factor\n\n\nthrust_deduction\nfloat\n\nThe thrust deduction factor\n\n\nwake_fraction\nfloat\n\nThe full-scale wake fraction\n\n\nstw\nfloat\n\nShips speed through water [m/s]\n\n\ndiameter\nfloat\n\nThe diameter of the ships propeller\n\n\nwater_density\nfloat\n1026\ndensity of water in the given conditions [kg/m^3]\n\n\nReturns\nfloat\n\nthis value can be in the ideal condition or trial depending on parameters used\n\n\n\ntotal resistance of the ship ultimately decides it’s maximum speed and the fuel consumption it has at a given speed\n\ntotal_resistance(5, 0.7, 0.8, 10, 2.3, 1026)\n\n32565.23999999998",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#corrected-propeller-shaft-speed",
    "href": "power.html#corrected-propeller-shaft-speed",
    "title": "Direct Power Analysis (power)",
    "section": "11 Corrected propeller shaft speed",
    "text": "11 Corrected propeller shaft speed\nThe corrected propeller shaft speed is \\[n = \\frac{V_S(1-w_{S})}{JD},\\] where \\(V_s\\) is the speed of the vessel, \\(w_S\\) is the full-scale wake fraction, \\(J\\) is the propeller advance coefficient in the ideal condition, and \\(D\\) is the diameter of the propeller. This equation is is a re-arranged version of propeller_flow with the substitution \\(V_A = V_S (1-w_S)\\)\nITTC equations: J-28\n\nsource\n\n11.1 propeller_speed\n\n propeller_speed (propeller_advance_coef:float, stw:float, diameter:float,\n                  wake_fraction:float)\n\nCalculate the propeller speed in m/s\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\npropeller_advance_coef\nfloat\nPropeller advance coefficient [n/a]\n\n\nstw\nfloat\nThe speed through water of the vessel [m/s]\n\n\ndiameter\nfloat\nDiamter of the propeller [m]\n\n\nwake_fraction\nfloat\nThe full scale wake fraction\n\n\nReturns\nfloat\nPropeller speed in rotations per second\n\n\n\nOnce calculated propeller speed can be inserted into the beggining of the calculation process to iterate the model to convergence and find the final value for \\(\\Delta P\\)\n\npropeller_speed(2, 10, 2, 0.5)\n\n1.25",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#power-in-the-ideal-conditions",
    "href": "power.html#power-in-the-ideal-conditions",
    "title": "Direct Power Analysis (power)",
    "section": "12 Power in the ideal conditions",
    "text": "12 Power in the ideal conditions\nAfter finding all the intermediary stages the final corrected power values can be calcualted. \\[P_{Did} = P_{Dms} - \\Delta P\\]\nThe calulation of these values is broken into two stages\n\nTrial: The calculations needed to get all the values relating to and required for values ‘in the trial condition’\nIdeal: The calculations needed to get all the values relating to and required for values ‘in the ideal condition’\n\nThe trial values are calculated first then the results are used to calculate the ideal values. once both phases have been completed the delivered power in the ideal condition can be found.\n\n12.1 Calculate values in the trial condition\n\nsource\n\n\n12.2 calculate_all_values_from_trial_phase\n\n calculate_all_values_from_trial_phase (V_s:float, P_dms:float,\n                                        eta_ms:float, delta_R:float,\n                                        delta_eta:float, delta_t:float,\n                                        delta_w:float, shaft_speed:float,\n                                        diameter:float, t_Rid:float,\n                                        w_Mid:float, number_shafts:float,\n                                        K_T, K_Q, J,\n                                        water_density:float=1026)\n\nPerform all the calculations to get the ‘trials conditions’ values\nCompleting the trial phase values returns a dictionary of values. If vectors are entered instead of floats then a dictionary of arrays is returned. Using this structure makes converting the output of the function in a pandas dataframe straightforword.\nAs the output is all scalers an index must be passed to the dataframe commend. The index be the same length as the vectors returned by calculate_all_values_from_trial_phase.\n\ntrial_values, K_coeffs = calculate_all_values_from_trial_phase(\n            V_s = 8.8,\n            P_dms = 13500,\n            eta_ms = 1.018,\n            delta_R = -44000,\n            delta_eta  = 0,\n            delta_t = 0,\n            delta_w = 0,\n            shaft_speed = 1.35, \n            diameter =6,\n            number_shafts = 2,\n            water_density = 1023,\n            t_Rid = 0.2,\n            w_Mid = 0.24,\n            J = np.linspace(0.3, 0.85, 12),\n            K_T = np.asarray([0.30, 0.27, 0.26, 0.24, 0.21, 0.20, 0.195, 0.17, 0.15, 0.13, 0.09, 0.08]),\n            K_Q = np.asarray([0.38,0.36,0.34,0.32,0.30,0.28,0.26,0.23,0.21,0.20,0.16,0.13])/10\n)\n\npd.DataFrame(trial_values, index = [0])\n\n\n\n\n\n\n\n\nK_Qms\nJ_ms\nK_Tms\ntau_Pms\nV_A\nw_Sms\nR_ms\nR_id\neta_Oms\neta_Rms\nt_ms\nw_Mms\neta_Dms\ne_ims\nw_Sid\n\n\n\n\n0\n0.000056\n1.084483\n-0.032797\n-0.027887\n8.78431\n0.001783\n-126796.729393\n-82796.729393\n-101.3081\n1.018\n0.2\n0.24\n-82.652683\n1.313443\n0.001783\n\n\n\n\n\n\n\n\n\n12.3 Calculate values in the ideal condition\n\nsource\n\n\n12.4 calculate_all_values_from_ideal_phase\n\n calculate_all_values_from_ideal_phase (V_s:float, P_dms:float,\n                                        delta_R:float, diameter:float,\n                                        number_shafts:float, t_Rid:float,\n                                        R_id:float, eta_Rms:float,\n                                        eta_Dms:float, w_Sid:float,\n                                        K_T_coeffs, K_Q_coeffs,\n                                        water_density:float=1026)\n\nintermediary function that calculates all the values in the ideal condition\nIn most cases the function will take the output of calculate_all_values_from_trial_phase. However there may be cases where some variables will be substituted. In the case below the total resistance in the ideal condition \\(R_{id}\\) has been repplaced with another value with the rest of the values unchanged\n\nideal_values = calculate_all_values_from_ideal_phase(\n            V_s = 8.8,\n            P_dms = 13500,\n            delta_R = -44000,\n            diameter =6,\n            number_shafts = 2,\n            t_Rid = 0.2,\n            R_id= 1.4e6, #trial_values['R_id'], #R_id is replaced with a different value \n            eta_Rms=trial_values['eta_Rms'],\n            eta_Dms=trial_values['eta_Dms'],\n            w_Sid=trial_values['w_Sid'],\n            K_T_coeffs =  K_coeffs[0],\n            K_Q_coeffs =  K_coeffs[1],\n            water_density = 1026\n)\nideal_values\n\n{'tau_Pid': 0.5608892942446079,\n 'J_id': 0.5839954628056303,\n 'K_Tid': 0.19129168674857802,\n 'K_Qid': 0.026521344043699324,\n 'eta_Oid': 0.6703940820835084,\n 'n_id': 1.8547261579189114,\n 'eta_Did': 0.7392819259246924,\n 'delta_P': 300871.69313356787}\n\n\nHowever, it should be remembered that data can be entered as an array resulting with an array being returned. Also remember that the functions will perform broadcasting automatically.\n\nideal_values = calculate_all_values_from_ideal_phase(\n            V_s = 8.8,\n            P_dms = 13500,\n            delta_R = -44000,\n            diameter =6,\n            number_shafts = 2,\n            t_Rid = 0.2,\n            R_id= np.array([1.8e6, 1.4e6, trial_values['R_id'] ]),\n            eta_Rms=trial_values['eta_Rms'],\n            eta_Dms=trial_values['eta_Dms'],\n            w_Sid=trial_values['w_Sid'],\n            K_T_coeffs =  K_coeffs[0],\n            K_Q_coeffs =  K_coeffs[1],\n            water_density = 1026\n)\n\npd.DataFrame(ideal_values, index = [0,1,2])\n\n\n\n\n\n\n\n\ntau_Pid\nJ_id\nK_Tid\nK_Qid\neta_Oid\nn_id\neta_Did\ndelta_P\n\n\n\n\n0\n0.721143\n0.538156\n0.208851\n0.028523\n0.627159\n2.012711\n0.691604\n320682.544239\n\n\n1\n0.560889\n0.583995\n0.191292\n0.026521\n0.670394\n1.854726\n0.739282\n300871.693134\n\n\n2\n-0.009672\n1.039962\n-0.010461\n0.002753\n-0.628948\n1.041530\n-0.693577\n-292808.768684\n\n\n\n\n\n\n\n\n\n12.5 Power delivered in the ideal condition\nThis function brings all the rest of the functions in this module together into a single function call. Generally it would be easiest to use this. However, in the case that iteration is necessary, creating a custom function with a loop would be better. Such functionality may added to the library later as its use is better understood\n\nsource\n\n\n12.6 delivered_power_ideal_condition\n\n delivered_power_ideal_condition (V_s:float, P_dms:float, eta_ms:float,\n                                  delta_R:float, delta_eta:float,\n                                  delta_t:float, delta_w:float,\n                                  shaft_speed:float, diameter:float,\n                                  t_Rid:float, w_Mid:float,\n                                  number_shafts:float, K_T, K_Q, J,\n                                  water_density:float=1026)\n\nCalculate the delivered power in the Ideal conditions\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nV_s\nfloat\n\n\n\n\nP_dms\nfloat\n\n\n\n\neta_ms\nfloat\n\n\n\n\ndelta_R\nfloat\n\n\n\n\ndelta_eta\nfloat\n\n\n\n\ndelta_t\nfloat\n\n\n\n\ndelta_w\nfloat\n\n\n\n\nshaft_speed\nfloat\n\n\n\n\ndiameter\nfloat\n\n\n\n\nt_Rid\nfloat\n\n\n\n\nw_Mid\nfloat\n\n\n\n\nnumber_shafts\nfloat\n\n\n\n\nK_T\n\n\n\n\n\nK_Q\n\n\n\n\n\nJ\n\n\n\n\n\nwater_density\nfloat\n1026\nreturns three results ideal_values, trial_values and the K coefficients\n\n\n\nAlthough this function produces a lot of output. Most can be ingored or used for checking results.\n\nideal_values, trial_values, K_coeffs = delivered_power_ideal_condition(\n            V_s = 8.8,\n            P_dms = 13500,\n            eta_ms = 1.018,\n            delta_R = -44000,\n            delta_eta  = 0,\n            delta_t = 0,\n            delta_w = 0,\n            shaft_speed = 1.35, \n            diameter =6,\n            number_shafts = 2,\n            water_density = 1023,\n            t_Rid = 0.2,\n            w_Mid = 0.24,\n            J = np.linspace(0.3, 0.85, 12),\n            K_T = np.asarray([0.30, 0.27, 0.26, 0.24, 0.21, 0.20, 0.195, 0.17, 0.15, 0.13, 0.09, 0.08]),\n            K_Q = np.asarray([0.38,0.36,0.34,0.32,0.30,0.28,0.26,0.23,0.21,0.20,0.16,0.13])/10\n)\n\nideal_values\n\n{'tau_Pid': -0.018209572919191754,\n 'J_id': 1.0600094727983314,\n 'K_Tid': -0.02046064182433527,\n 'K_Qid': 0.0015466896077949155,\n 'eta_Oid': -2.2317521577870694,\n 'n_id': 1.3811684700285562,\n 'eta_Did': -1.8207853408921804,\n 'delta_P': -386663.16162853956}",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "power.html#how-it-all-hangs-together",
    "href": "power.html#how-it-all-hangs-together",
    "title": "Direct Power Analysis (power)",
    "section": "13 How it all hangs together",
    "text": "13 How it all hangs together\nThe relationships between the direct power equations are pretty complicated. The below flow diagram can help understand how it all hangs together\n\n\n\n\n\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]\n\n\n\n\n\n\n\nimport nbdev; nbdev.nbdev_export()",
    "crumbs": [
      "Direct Power Analysis (power)"
    ]
  },
  {
    "objectID": "trig.html",
    "href": "trig.html",
    "title": "Useful trigonometry (trig)",
    "section": "",
    "text": "These functions form the basis of the functions used in Appendix E of ITTC. This module is the trigonometry the underlying the appendix E. However, in general for seatrials work, you can use the wind evaluation module directly.\nAll the functions in this module can take arrays and perform vectorised operations.",
    "crumbs": [
      "Useful trigonometry (trig)"
    ]
  },
  {
    "objectID": "trig.html#component-functions",
    "href": "trig.html#component-functions",
    "title": "Useful trigonometry (trig)",
    "section": "0.1 Component functions",
    "text": "0.1 Component functions\nThe first two functions in this section are helper functions used to create the later functions. These functions are\n\n\\(x\\,\\text{cos}(\\theta)\\)\n\\(x\\,\\text{sin}(\\theta)\\)\n\n\nsource\n\n0.1.1 opposite_magnitude_fn\n\n opposite_magnitude_fn (magnitude:float, angle:float)\n\nProduct of sin and magnitude\n\n\n\n\nType\nDetails\n\n\n\n\nmagnitude\nfloat\nThe true speed\n\n\nangle\nfloat\nThe angle in radians\n\n\nReturns\nint\nThe vertical component of the magnitude\n\n\n\nIn the example below a ship travelling due south (90\\(^\\circ\\) or \\(\\frac{\\pi}{2}\\)) at 20 knots, as a result the vertical component of its speed is \\(-20\\).\n\ntest_eq(opposite_magnitude_fn(20, np.pi/2), 20)\n\n\nsource\n\n\n0.1.2 adjacent_magnitude_fn\n\n adjacent_magnitude_fn (magnitude:float, angle:float)\n\nProduct of cos and magnitude\n\n\n\n\nType\nDetails\n\n\n\n\nmagnitude\nfloat\nThe true speed\n\n\nangle\nfloat\nThe Ange in radians\n\n\nReturns\nint\nThe adjacent component of the magnitude\n\n\n\nUsing the same example as the previous example we see that the resultant magnitude is 0\n\ntest_eq(round(adjacent_magnitude_fn(20, np.pi/2), 5), 0)",
    "crumbs": [
      "Useful trigonometry (trig)"
    ]
  },
  {
    "objectID": "trig.html#the-law-of-cosines",
    "href": "trig.html#the-law-of-cosines",
    "title": "Useful trigonometry (trig)",
    "section": "1.1 The Law of cosines",
    "text": "1.1 The Law of cosines\nThe law of cosines is used find the magnitude of a relative to b for a given angle between them. In shipping this is used to find the relative windspeed from the true windspeed, relative current from true current, etc.\n\nsource\n\n1.1.1 law_of_cosines\n\n law_of_cosines (a:float, b:float, theta:float)\n\nFinds the length of side c using the angle theta opposite c and the length of the other two sides\n\n\n\n\nType\nDetails\n\n\n\n\na\nfloat\nside a which is along the x-axis\n\n\nb\nfloat\nside b makes the angle \\(\\theta\\) with side a\n\n\ntheta\nfloat\nthe angle in radians opposite side c\n\n\nReturns\nfloat\nThe magnitude of b relative to a\n\n\n\nIn a right angled triangle the law of cosines simplifies to the pythagoras theorem\n\ntest_eq(law_of_cosines(3,4, np.pi/2), 5)",
    "crumbs": [
      "Useful trigonometry (trig)"
    ]
  },
  {
    "objectID": "trig.html#finding-an-unknown-angle-of-a-triangle",
    "href": "trig.html#finding-an-unknown-angle-of-a-triangle",
    "title": "Useful trigonometry (trig)",
    "section": "1.2 Finding an unknown angle of a triangle",
    "text": "1.2 Finding an unknown angle of a triangle\nConsider a triangle where the length of two sides are known and 1 angle is known where that angle is opposite the unknown side. Either of the unknown angles can be found by first using the single known angle and 1 of the known sides to create a right angle triangle, where the unknown side is the hypontenuse. From that using arctan the required angle can be found\n\\(\\text{tan} (\\gamma) = \\frac{a \\, \\text{sin}(\\alpha))}{b + a \\,\\text{cos}(\\alpha)}\\)\nThis means we can obtain the value of \\(\\gamma\\) using arctan\n\nsource\n\n1.2.1 find_gamma_fn\n\n find_gamma_fn (a:int, b:int, alpha:int, constrain_to_positive:bool=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\na\nint\n\nmagnitude of a\n\n\nb\nint\n\nmagnitude of b\n\n\nalpha\nint\n\nthe angle between b and a in radians\n\n\nconstrain_to_positive\nbool\nFalse\nShould the function return a value between 0 and 2 pi\n\n\nReturns\nint\n\nthe angle in radians between a and the relative magnitude of b\n\n\n\nProviding different values that are equally either side of \\(90^\\circ\\) produces values that are negative\n\nfind_gamma_fn(np.array([3,3]), np.array([4, 4]), np.array([np.pi*0.5, np.pi*1.5]), constrain_to_positive = False)\n\narray([ 0.64350111, -0.64350111])\n\n\nBy setting “constrain_to_positive” to true the function ensures that the angle stays the same but is flipped to be positive.\n\nfind_gamma_fn([3,3], [4, 4], [np.pi*0.5, np.pi*1.5], constrain_to_positive = True)\n\narray([0.64350111, 5.6396842 ])",
    "crumbs": [
      "Useful trigonometry (trig)"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pyseatrials",
    "section": "",
    "text": "The library pyseatrials is a collection of functions, written in Python, that are useful for estimating ship performance from sea trials data. The library is based on ITTC Preparation, Conduct and Analysis of Speed/Power Trials. 7.5-04-01-01.1 and is designed to make the process of estimating ships peformance easier, faster and more reliable by packaging all the equations into a clearly documented python library with examples and code testing for all functions.\nThere full documentation is available at https://silverstream-tech.github.io/pyseatrials/\nThe library uses nbdev by fastdotai and most functions depend solely on numpy.",
    "crumbs": [
      "pyseatrials"
    ]
  },
  {
    "objectID": "index.html#some-useful-definations",
    "href": "index.html#some-useful-definations",
    "title": "pyseatrials",
    "section": "4.1 Some useful definations",
    "text": "4.1 Some useful definations\n\nTank test: a test performed at a marine testing facilty on a scale model of the vessel. This is used to obtain valuable performance data which can be scaled to better understand the real performance of the ship during seatrials.",
    "crumbs": [
      "pyseatrials"
    ]
  },
  {
    "objectID": "wind_resistance_coef.html",
    "href": "wind_resistance_coef.html",
    "title": "Wind resistance coefficients (wind_res)",
    "section": "",
    "text": "In order to caluclate the wind resistance experienced by the ship, the wind resistance loading coefficients need to be known. The wind resistance loading coefficients are dependent on the direction the wind is blowing relative to the ship. These coefficients can be found using the following three methods\nThe first two and fourth approaches are used to create the coefficients specific for the ship. The third option is used when no such simulations have been performed and are based on a set of generic ship designs.",
    "crumbs": [
      "Wind resistance coefficients (wind_res)"
    ]
  },
  {
    "objectID": "wind_resistance_coef.html#load-wind-resistance-coefficients",
    "href": "wind_resistance_coef.html#load-wind-resistance-coefficients",
    "title": "Wind resistance coefficients (wind_res)",
    "section": "0.1 Load wind resistance coefficients",
    "text": "0.1 Load wind resistance coefficients\nWhen there has been no wind tunnel test or CDF analysis the wind resistance coefficients must be found using datasets of look up tables representing generic ship designs for a variety of classes. pyseatrials contains the wind loading factor datasets from ITTC. These data sets have been included as 9 dataframes depending on ship type. To load the data frame enter the name of the ship type to load. The available ship types are\n\nGENERAL_CARGO\nLNG_CARRIER_INT\nCRUISE_FERRY\n280_KDWT_TANKER\nLNG_CARRIER\nHANDY_SIZE_BULK_CARRIER\n6800_TEU_CONTAINERSHIP\nMULTI_PURPOSE_CARRIER\n\n\nsource\n\n0.1.1 load_wind_coefficients\n\n load_wind_coefficients (vessel_type:str)\n\nLoad a wind coefficient table for a generic ship class. Datasets from ITTC\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nvessel_type\nstr\nThe name of the vessel type. Must be one of 9 options\n\n\n\nLoading a wind resistance dataset for a specific ship type is straight forward if no other dataset is available.\nAll datasets contain angle of attack in both radians and degrees, the subsequent columns refer to the ship state\n\ngeneral_cargo = load_wind_coefficients(\"GENERAL_CARGO\")\n\ngeneral_cargo\n\n\n\n\n\n\n\n\nangle_of_attack\nangle_of_attack_degs\naverage\n\n\n\n\n0\n0.000000\n0\n-0.60\n\n\n1\n0.174533\n10\n-0.87\n\n\n2\n0.349066\n20\n-1.00\n\n\n3\n0.523599\n30\n-1.00\n\n\n4\n0.698132\n40\n-0.88\n\n\n5\n0.872665\n50\n-0.85\n\n\n6\n1.047198\n60\n-0.65\n\n\n7\n1.221730\n70\n-0.42\n\n\n8\n1.396263\n80\n-0.27\n\n\n9\n1.570796\n90\n-0.09\n\n\n10\n1.745329\n100\n0.09\n\n\n11\n1.919862\n110\n0.49\n\n\n12\n2.094395\n120\n0.84\n\n\n13\n2.443461\n140\n1.39\n\n\n14\n2.617994\n150\n1.47\n\n\n15\n2.792527\n160\n1.34\n\n\n16\n2.967060\n170\n0.92\n\n\n17\n3.141593\n180\n0.82",
    "crumbs": [
      "Wind resistance coefficients (wind_res)"
    ]
  },
  {
    "objectID": "wind_resistance_coef.html#interpolate-the-wind-loading-coefficients",
    "href": "wind_resistance_coef.html#interpolate-the-wind-loading-coefficients",
    "title": "Wind resistance coefficients (wind_res)",
    "section": "0.2 Interpolate the wind loading coefficients",
    "text": "0.2 Interpolate the wind loading coefficients\nThe dataset loaded previously only contains the load coefficients at specific angles. Interpolation is needed to match these coefficients to the wind acting on the ship.There are many ways to interpolate these values, pyseatrials uses simple linear interpolation. Linear interpolation has been chosen over other approaches as it can be vectorised and reduces package dependencies. In addition the ultimate difference, between e.g. linear vs spline interpolation, in resistive force will be small compared to the magnitude of forces acting on the ship.\n\nsource\n\n0.2.1 interpolate_cx\n\n interpolate_cx (df, relative_wind_direction:float, ship_state:str)\n\nFind a linearly interpolated value for wind resistance coefficient\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndf\n\ndataframe of the wind resistance dataset\n\n\nrelative_wind_direction\nfloat\nThe angle of the wind relative to the ship [rads]\n\n\nship_state\nstr\nThe state of the ship the resistance should be evaluated in. Chosen from the columns of the wind resistance datasets\n\n\nReturns\nfloat\nThe dimensionless wind resistance coefficient\n\n\n\nUsing the example of the general cargo ship using four different wind direction scenarios (0, 55, 180, 280 degrees) we get the interpolated loading coefficients. Some ships have data for different states such as ‘laden’ and ‘ballast’ the General Cargo dataset only has a single state ‘average’.\n\ndegs = [0, 55, 120, 180 ]\nrads = np.deg2rad(degs) #convert the degrees to radians\ncx_vals = interpolate_cx(general_cargo, rads, 'average')\nprint(cx_vals)\n\n[-0.6  -0.75  0.84  0.82]\n\n\n\nimport pandas as pd\n\nThe wind resistance coefficients can then be used to find the actual wind resistance experienced by the ship\n\nfrom pyseatrials.general import *\n\n\nwind_resistance_linear = wind_resistance(air_density = 1.2,\n                   wind_resistance_coef_rel = cx_vals,\n                   wind_resistance_coef_zero = cx_vals[0],\n                   area = 500,\n                   relative_wind_speed = 20,\n                   sog = 10)\n\n#convert to kN\nresistance_linear_kN = np.round(wind_resistance_linear/1000)\nprint(resistance_linear_kN )\n\n[-54. -72. 119. 116.]\n\n\nOther interpolations methods can be used such as spline interpolation from the scipy library.\n\nfrom scipy.interpolate import make_interp_spline\n\n\ncx_spline = make_interp_spline(general_cargo['angle_of_attack'], general_cargo['average'] )\n\nThe difference between the load coefficients produced by the two models can be shown in the plot below. Across the full range there is almost no difference.\n\nimport matplotlib.pyplot as plt\n\n\nxs = np.linspace(-3, 3, 100)\nxvals = np.linspace(0, np.pi, 50)\nyinterp_lin = np.interp(xvals, general_cargo['angle_of_attack'], general_cargo['average'])\nyinterp_spline = cx_spline(xvals)\nplt.plot(general_cargo['angle_of_attack'], general_cargo['average'], 'ro')\nplt.plot(xvals, yinterp_lin,'g-', lw=1, label='Linear')\nplt.plot(xvals, yinterp_spline,'b-', lw=1, label='Linear')\nplt.legend(loc='best')\nplt.show()\n\n\n\n\n\n\n\n\nThe difference in terms of actual resistive force between linear and spline interpolation is also very small.\n\nwind_resistiance_spline = wind_resistance(air_density = 1.2,\n                   wind_resistance_coef_rel = cx_spline(rads),\n                   wind_resistance_coef_zero = cx_spline(rads)[0],\n                   area = 500,\n                   relative_wind_speed = 20,\n                   sog = 10)\n#convert to kN\nresitance_spline_kN = np.round(wind_resistiance_spline/1000)\n\n#difference in wind resistance between the two models in kN\nprint('difference in kN between the two interpolation methods for all 4 angles of attack '+str(resistance_linear_kN - resitance_spline_kN))\n\ndifference in kN between the two interpolation methods for all 4 angles of attack [0. 2. 0. 0.]",
    "crumbs": [
      "Wind resistance coefficients (wind_res)"
    ]
  },
  {
    "objectID": "shallow_water.html",
    "href": "shallow_water.html",
    "title": "Shallow water corrections (shallow)",
    "section": "",
    "text": "When ships pass through shallow water, they experience higher resistance due to changes in the viscous friction and the impact of squatting or sinkage in the water. These effects are due to the water passing under the ship being constricted and thus having a higher velocity. The change in velocity results in a difference in the buoyancy of the ship in accordance with the Bernoulli principle, which states that\n\\[P +\\frac{1}{2} \\rho v^2 + \\rho g h = \\textrm{Constant}\\]\nWhere \\(P\\) is pressure, \\(\\rho\\) is water density, \\(v\\) is the speed through water, \\(g\\) is gravity, and \\(h\\) is the distance from the reference plane. As can be seen, an increase in water velocity must be balanced by a change in at least one of the other two variables. Changes in pressure result in the ship’s buoyancy being reduced, causing it to sink slightly or squat. As the coefficient of friction experienced by the vessel is proportional to the square of the speed through water, the frictional resistance on the ship increases. A secondary effect is that the sinkage exposes an additional surface area of the ship to the water, increasing the friction effects further. Finally, as the ship’s hull gets closer to the sea floor, the boundary layer between the hull and the free-flowing water thickens and becomes more turbulent increasing resistance. As a result of the additional resistance, the engine is required to deliver more power to maintain speed.\nAs such, when calculating the performance of a ship in shallow water, care needs to be taken to adjust for the effects this produces or risk misinterpreting the performance results.",
    "crumbs": [
      "Shallow water corrections (shallow)"
    ]
  },
  {
    "objectID": "shallow_water.html#importing-the-module",
    "href": "shallow_water.html#importing-the-module",
    "title": "Shallow water corrections (shallow)",
    "section": "1 Importing the module",
    "text": "1 Importing the module\nThe module is called shallow import as\nfrom pyseatrials.shallow import *",
    "crumbs": [
      "Shallow water corrections (shallow)"
    ]
  },
  {
    "objectID": "shallow_water.html#raven-shallow-water-correction",
    "href": "shallow_water.html#raven-shallow-water-correction",
    "title": "Shallow water corrections (shallow)",
    "section": "2 Raven shallow water correction",
    "text": "2 Raven shallow water correction\nAlthough there are several correction approaches to correcting for the effect of shallow water this library uses the method introduced by Raven in 2016 and described fully in Raven 2019. The correction has two component resistance due to changes in viscous friction, resistance due to sinkage.\nConsider the following\n\\(R_{V, \\,\\textrm{deep}} = C_v'\\frac{1}{2} \\rho  V_S^2 S\\)\nIs the viscous friction in deep water, where \\(C_v'\\) is the coeficient of viscous friction, \\(\\rho\\) is the density of water, \\(V_S\\) is the speed through water, and \\(S\\) is the wetted surface area\nThe correction due to the changes in viscous resistance are given as\n\\[ R_{V} = R_{V, \\,\\textrm{deep}} 0.57 (\\frac{T_M}{h})^{1.79},\\]\nWhere, \\(T_M\\) is the draught at midship and \\(h\\) is the water depth.\nThe sinkage is calculated using the following method,\n\\[d(\\textrm{sinkage}) = 1.46 \\frac{\\nabla}{L_\\textrm{pp}^2}\\left[\n\\frac{\\textrm{Fr}_\\textrm{h}^2}{\\sqrt{1 - \\textrm{Fr}_\\textrm{h}^2}} -\n\\frac{\\textrm{Fr}_\\textrm{hd}^2}{\\sqrt{1 - \\textrm{Fr}_\\textrm{hd}^2}}\n\\right],\\]\nwhere L_ is the length between perpendiculars, \\(\\nabla\\) is \\(\\nabla = L_\\textrm{pp} B T_M C_B\\), and \\(B\\) is the ships beam (m), \\(C_B\\) is the dimensionless block coefficient, \\(\\textrm{Fr}_\\textrm{hd}\\) is the Froude number where \\(h = 0.3 L_\\textrm{pp}\\), \\(\\textrm{Fr}_\\textrm{h}\\) is the Froude number where \\(h\\) is water depth. It should be noted that $d() $.\nAdditional displacement due to sinkage is then found such that\n\\[\\delta \\nabla =  \\begin{cases}\nd(\\textrm{sinkage})\\frac{A_W}{\\nabla} & \\text{if } d(\\textrm{sinkage})\\frac{A_W}{\\nabla} &lt; 0.05 \\\\\n0.05 & \\text{if } d(\\textrm{sinkage})\\frac{A_W}{\\nabla} \\geq 0.05\n\\end{cases} \\]\nWhere \\(A_W\\) is the water plane area. With \\(\\delta nabla\\) now known we find the sinkage value using\n\\[\\textrm{rsink} = (1- \\delta \\nabla)^\\frac{2}{3} \\]\nWe then correct the power shallow water power to deep water power using\n\\[P_\\textrm{D,deep} = \\frac{P_\\textrm{D, shallow}}{\\textrm{rsink}} - \\frac{\\Delta R_V V_S}{\\eta_{Did}}\\]\nFinally we perform a check to ensure that\n\\[R_{V, \\,\\textrm{deep}}  \\leq  \\frac{P_\\textrm{D,deep} \\eta_\\textrm{Did}}{V_s}\\]\nif the above condition is not satisfied \\(R_{V, \\,\\textrm{deep}}\\) is set to the upper limit and the process is repeated.\n\nsource\n\n2.1 shallow_water_correction\n\n shallow_water_correction (coef_visc_frict:float, stw:float, L_pp:float,\n                           beam:float, draught:float, C_B:float,\n                           displacement:float, wetted_surface_area:float,\n                           waterplane_area:float, power:float, etad:float,\n                           water_density:float, water_depth:float,\n                           R_V_deep=None)\n\nPerform Raven corrections for shallow water performance\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncoef_visc_frict\nfloat\n\nthe coefficient of viscous friction [none]\n\n\nstw\nfloat\n\nspeed through water [m/s^2]\n\n\nL_pp\nfloat\n\nThe length between perpendiculars of the ship [m]\n\n\nbeam\nfloat\n\nThe beam of the ship [m]\n\n\ndraught\nfloat\n\nThe draught at mid-ship [m]\n\n\nC_B\nfloat\n\nThe block coefficient of the ship [none]\n\n\ndisplacement\nfloat\n\nThe measured displacement from the trial [m^3]\n\n\nwetted_surface_area\nfloat\n\nThe wetted surface area of the ships hull [m^2]\n\n\nwaterplane_area\nfloat\n\narea of the waterline from the trail [m^2]\n\n\npower\nfloat\n\nThe engine power [kW]\n\n\netad\nfloat\n\nThe propulsive efficiency of the propeller [none]\n\n\nwater_density\nfloat\n\nWater density [kg/m^3]\n\n\nwater_depth\nfloat\n\nThe depth of the water [m]\n\n\nR_V_deep\nNoneType\nNone\nThe viscous friction experienced by the ship, this is left as none and used internally by the function\n\n\nReturns\ntuple\n\nReturns 3 values the equivalent deep water power, the sinkage, the viscous resistance correction\n\n\n\nThe example below shows a simple use case\n\ncoef_visc_frict = 0.0015\nstw = np.array([8.0, 10.0, 12.0])  # m/s\nL_pp = 200.0  # m\nbeam = 30.0  # m\ndraught = 10.0  # m\nC_B = 0.7\ndisplacement = 16800.0 # m^3\nwetted_surface_area = 2500.0  # m^2\nwaterplane_area = 1920.0\npower = np.array([6000.0, 8000.0, 10000.0])*1000  # W\netad = 0.7\nwater_density = 1025.0\nwater_depth = np.array([40.0, 40.0, 40.0])  # m\n\n# Call the function with the example inputs\nP_D_deep, sinkage, R_V = shallow_water_correction(coef_visc_frict, stw, L_pp, beam, draught,\n                                                  C_B, displacement, wetted_surface_area,\n                                                  waterplane_area, power, etad,\n                                                  water_density, water_depth)\nP_D_deep /= 1000\n# Print the results\nprint(\"Equivalent deep water power:\", (P_D_deep).astype(int), \"kW\")\nprint(\"Sinkage:\", np.round(sinkage,2), \"m\")\nprint(\"Viscous resistance correction:\", (R_V).astype(int), \"N\")",
    "crumbs": [
      "Shallow water corrections (shallow)"
    ]
  },
  {
    "objectID": "full_example.html",
    "href": "full_example.html",
    "title": "Which ship is best?",
    "section": "",
    "text": "1 Sailing conditions\nThe three ships are being tested in similar but slightly different sailing conditions. The below code shows how this data is generated. SAILLLLLLLLLLLl",
    "crumbs": [
      "Which ship is best?"
    ]
  },
  {
    "objectID": "basic_hydro_functions.html",
    "href": "basic_hydro_functions.html",
    "title": "Basic hydro functions (basic)",
    "section": "",
    "text": "This module contains low level functions related to naval architecture and hydrodynamics. Many of them are called by other functions within the library.",
    "crumbs": [
      "Basic hydro functions (basic)"
    ]
  },
  {
    "objectID": "basic_hydro_functions.html#load-water-dynamic-viscosity-table",
    "href": "basic_hydro_functions.html#load-water-dynamic-viscosity-table",
    "title": "Basic hydro functions (basic)",
    "section": "0.1 Load Water Dynamic Viscosity Table",
    "text": "0.1 Load Water Dynamic Viscosity Table\n\nsource\n\n0.1.1 load_water_properties\n\n load_water_properties ()\n\n*loads a 2D lookup table of water dynamic viscosity\nReturns: pd.DataFrame: dataframe of water properties*",
    "crumbs": [
      "Basic hydro functions (basic)"
    ]
  },
  {
    "objectID": "basic_hydro_functions.html#calculate-the-salinity-of-water",
    "href": "basic_hydro_functions.html#calculate-the-salinity-of-water",
    "title": "Basic hydro functions (basic)",
    "section": "0.2 Calculate the Salinity of Water",
    "text": "0.2 Calculate the Salinity of Water\n\nsource\n\n0.2.1 calc_salinity\n\n calc_salinity (measured_density:float, measured_temperature:float)\n\n*calculate water salinity from density and temperature using UNESCO 1983 (EOS 80) polynomial\nArgs: measured_density (float): measured water density measured_temperature (float): measured water temperature\nReturns: float: water salinity*\n\n\n\n\nType\nDetails\n\n\n\n\nmeasured_density\nfloat\nmeasured water density [kg/m3]\n\n\nmeasured_temperature\nfloat\nmeasured water temperature [degC]\n\n\nReturns\nfloat",
    "crumbs": [
      "Basic hydro functions (basic)"
    ]
  },
  {
    "objectID": "basic_hydro_functions.html#dynamic-viscosity",
    "href": "basic_hydro_functions.html#dynamic-viscosity",
    "title": "Basic hydro functions (basic)",
    "section": "0.3 Dynamic viscosity",
    "text": "0.3 Dynamic viscosity\nAlthough a typical value of 1.18e-3 [kg/(ms)] is often used for dynamic viscosity, calculating the value at the current moment in time can still be advantageous. In such cases, the dynamic viscosity of seawater can be found using the equations of Sharkawy et al 2010. This equation is used in the TEOS-10 standard and is implemented here.\n\\[\\mu_{SW} = \\mu_W (1 + AS +BS^2)\\]\n\\[\\mu_W = 4.2844e^{-5} + \\frac{1}{0.157(T + 64.993)^2 - 91.296} \\]\n\\[A = 1.541 + 1.998e^{-2} T - 9.52e^{-5}T^2 \\] \\[B = 7.974 - 7.561e^{-2}T + 4.724e^{-4}T^2 \\]\nFor the above equations, \\(T\\) is temperature in degrees Celsius, and \\(S\\) is the salinity in \\(\\frac{g}{kg}\\). The Sharkawy correlation is valid for the following conditions\n\n\\(0 \\leq  S \\leq 150\\)\n\\(0 \\leq T \\leq 180\\)\n\nThis method has an average accuracy of \\(\\pm\\) 4%. For alternative methods on calcualting the dynamic viscosity of seawater see Qasem et al 2021.\n\nsource\n\n0.3.1 dynamic_viscosity\n\n dynamic_viscosity (salinity:float, temperature:float)\n\nCalculate the dynamic viscosity dependent on temperature and salinity\n\n\n\n\nType\nDetails\n\n\n\n\nsalinity\nfloat\nA positive value of the water salinity [g/kg]\n\n\ntemperature\nfloat\nThe temperature in celsius [C]\n\n\nReturns\nfloat\nreturns values in [kg/ms]\n\n\n\nApplying the function to a range of temperatures shows that the viscosity is quite temperature dependent\n\ndynamic_viscosity(38e-3, np.linspace(10, 35, 5))\n\narray([0.00140539, 0.00118849, 0.00102094, 0.0008885 , 0.0007818 ])\n\n\nLooking at a range of both temperature and salinity combinations, the viscosity appears to be more dependent on temperature than salinity in the range of possible values we find in the sea\n\nimport matplotlib.pyplot as plt\n\n\nnp.linspace(25, 40, 16)\n\narray([25., 26., 27., 28., 29., 30., 31., 32., 33., 34., 35., 36., 37.,\n       38., 39., 40.])\n\n\n\ncounts = 50\ncomb_array = np.array(np.meshgrid(np.linspace(25, 40, counts )*10**(-3), np.linspace(10, 35, counts))).T.reshape(-1, 2)\n\ncomb_array\n\nres = dynamic_viscosity(comb_array[:,0], comb_array[:,1]).reshape(counts,counts)\n\nplt.imshow(res, cmap = 'hot')\nplt.colorbar()\nplt.title(\"Dynamic viscosity\")\nplt.ylabel('Salinity')\nplt.xticks(np.linspace(0, 50, 10 ) ,np.linspace(25, 40, 10).astype(int), rotation=  45)\nplt.xticks(np.linspace(0, 50, 10 ) ,np.linspace(10, 35, 10).astype(int), rotation=  45)\nplt.xlabel('temperature')\n\nText(0.5, 0, 'temperature')\n\n\n\n\n\n\n\n\n\n\n\n0.3.2 Kinematic viscosity\n\\[v = \\frac{\\mu_{SW}}{\\rho},\\]\nwhere \\(\\mu_{SW}\\) is the dynamic viscosity of seawater, and \\(\\rho\\) is the density of the water\n\nsource\n\n\n0.3.3 kinematic_viscosity_fn\n\n kinematic_viscosity_fn (dynamic_viscosity:float=0.00118,\n                         water_density:float=1026)\n\nA simple wrapper calculating the ratio of dynamic viscosity and water density\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndynamic_viscosity\nfloat\n0.00118\nThis value is typically 1.18e-3 [kg/(ms)]\n\n\nwater_density\nfloat\n1026\nThe density of water under current conditions [kg/m^3]\n\n\nReturns\nfloat\n\n[m^2/s]\n\n\n\nThe kinematic viscosity can be calculated without entering any parameters, this uses the default values only\n\nkinematic_viscosity_fn()\n\n1.1500974658869397e-06\n\n\nHowever if the water conditions are not those of the default these alternative values can be entered as required\n\ndynamic_visc = 1.18e-3\nwater_density  = 1050\nkinematic_viscosity_fn(dynamic_visc, water_density)\n\n1.1238095238095239e-06",
    "crumbs": [
      "Basic hydro functions (basic)"
    ]
  },
  {
    "objectID": "basic_hydro_functions.html#reynolds-number",
    "href": "basic_hydro_functions.html#reynolds-number",
    "title": "Basic hydro functions (basic)",
    "section": "0.4 Reynolds number",
    "text": "0.4 Reynolds number\nThe reynolds number is a common formalua used throughout physiscs and engineering desciplines. Low reynolds numbers typically indicate laminar flow whilst high reynolds numbers typically indicate turbulent flow. However, in the case of ships the Reynolds number will always be large, however it is still a valuable component of many other calculations used by marine architects.\n\\[\\text{Re} = \\frac{V_s L_{os}}{v}, \\] where \\(V_s\\) is the speed through wataer, \\(L_{os}\\) is the length overall submerged of the ship, and \\(v\\) is the kinematic viscosity.\n\nsource\n\n0.4.1 reynolds_number_fn\n\n reynolds_number_fn (stw:float, length:float, kinematic_viscosity:float)\n\nThe Reynolds number is a element of fluid dynamics and is often used to predict whether flow is laminar or turbulent\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nstw\nfloat\nSpeed through water [m/s]\n\n\nlength\nfloat\nLength of the vessel, \\(L_{os}\\) Length overall submerged is typically used [m]\n\n\nkinematic_viscosity\nfloat\n[m^2/s]\n\n\nReturns\nfloat\nReynolds number is dimensionless\n\n\n\nAs can be seen due to the small values of kinematic viscosity even a small ship going relatively slowly (approx 10kn) has a large reynolds number\n\nreynolds_number_fn(5, 50, 1.13e-6)\n\n221238938.05309734",
    "crumbs": [
      "Basic hydro functions (basic)"
    ]
  },
  {
    "objectID": "basic_hydro_functions.html#froude-number",
    "href": "basic_hydro_functions.html#froude-number",
    "title": "Basic hydro functions (basic)",
    "section": "0.5 Froude Number",
    "text": "0.5 Froude Number\nThe ratio of flow inertia to an external field. The Froude number is often used in estimating the resistance of a partially submerged object in water\n\\[\\text{Fr} = \\frac{V_s}{\\sqrt(g L_{WL})}, \\] where \\(V_S\\) is the speed through water, \\(L_{WL}\\) is the length at waterline, and \\(g\\) is acceleration due to gravity.\n\nsource\n\n0.5.1 froude_number_fn\n\n froude_number_fn (stw:float, length:float, gravity:float=9.81)\n\nThe Froude number is useful for calculating the water resistance\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nstw\nfloat\n\nspeed through water [m/s]\n\n\nlength\nfloat\n\nLength of vessel, typically \\(L_{wl}\\) Length of waterline [m]\n\n\ngravity\nfloat\n9.81\nacceleration due to gravity [m/s^2]\n\n\nReturns\nfloat\n\nThe Froude number is a dimensionless value\n\n\n\nAs the Froude number is inversevly proportional to the size of the vessel, froude numbers tend to be small for ships which also tend to go at slower speeds. Relative to the Reynolds number the Froude number is always much smaller.\n\nfroude_number_fn(10, 50)\n\n0.4515236409857309",
    "crumbs": [
      "Basic hydro functions (basic)"
    ]
  },
  {
    "objectID": "basic_hydro_functions.html#frictional-resistance-coefficent",
    "href": "basic_hydro_functions.html#frictional-resistance-coefficent",
    "title": "Basic hydro functions (basic)",
    "section": "0.6 Frictional resistance coefficent",
    "text": "0.6 Frictional resistance coefficent\nThe resistance coefficient related to the resistance of the water flowing over the hull\n\\[ C_F = \\frac{c_1}{(log_{10}Re - 2)^2} + c_2,\\]\nWhere \\(Re\\) is the Reynolds number and \\(c_1\\) and \\(c_2\\) are constant adjustment values. ITTC-1957 (Hadler 1958) use the model-ship correlation line\n\\[ C_F = \\frac{0.075}{(log_{10}Re - 2)^2} ,\\]\nWhich is the default setting in pyseatrials\n\nsource\n\n0.6.1 CF_fn\n\n CF_fn (reynolds_number:float, c1:float=0.075, c2:float=0)\n\nAn essential part of calculating the resistance experienced by the ship\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nreynolds_number\nfloat\n\nindicating the type of flow of the water\n\n\nc1\nfloat\n0.075\nAn adjustment value dault from ITTC-1957\n\n\nc2\nfloat\n0\nAn adjustment value the default is 0\n\n\nReturns\nfloat\n\nThis is a dimensionaless value\n\n\n\n\nCF_fn(1e6)\n\n0.0046875",
    "crumbs": [
      "Basic hydro functions (basic)"
    ]
  },
  {
    "objectID": "basic_hydro_functions.html#roughness-resistance-coefficient",
    "href": "basic_hydro_functions.html#roughness-resistance-coefficient",
    "title": "Basic hydro functions (basic)",
    "section": "0.7 Roughness resistance coefficient",
    "text": "0.7 Roughness resistance coefficient\nThe \\(19^{th}\\) ITTC proposed a formula that corrects for the roughness of the vessel hull.\n\\[\\Delta C_F = \\frac{11}{250} \\left(  \\left(\\frac{k_s}{L_{WL}}\\right)^{\\frac{1}{3}} -10 \\cdot \\text{Re}^{-\\frac{1}{3}} \\right) + \\frac{1}{8000} , \\]\nwhere \\(k_s\\) is the surface roughness, \\(L_{WL}\\) is the length of vessel at waterline, and \\(Re\\) is the Reynolds number for current conditions.\nThis value is used in several other adjustments and calculations. Function for obtaining it is found here.\nOther names for this variable are Roughness allowence\n\nsource\n\n0.7.1 roughness_resistance_fn\n\n roughness_resistance_fn (length:float, reynolds_number:float,\n                          surface_roughness:float=0.00015)\n\nThe function CF_fn calculates a dimensionless value representing the resistance experienced by a ship based on the given parameters.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlength\nfloat\n\nLength of the vessel at waterline [m]\n\n\nreynolds_number\nfloat\n\ndimensionless value describing flow properties\n\n\nsurface_roughness\nfloat\n0.00015\nThe default value is outdated an modern hull covering are likely considerably less rough [m]\n\n\nReturns\nfloat\n\nThe dimensionless friction factor representing surface roughness of the hull\n\n\n\n\nroughness_resistance_fn(189, 2.63e9)\n\n0.00021361371568178405",
    "crumbs": [
      "Basic hydro functions (basic)"
    ]
  },
  {
    "objectID": "basic_hydro_functions.html#air-density",
    "href": "basic_hydro_functions.html#air-density",
    "title": "Basic hydro functions (basic)",
    "section": "4.1 Air Density",
    "text": "4.1 Air Density\nCalcuate the air density based on the the function “FUNCTION ESW(T)” in https://icoads.noaa.gov/software/other/profs\n\nsource\n\n4.1.1 air_density\n\n air_density (P:float, T:float, RH:float)\n\n*Calculate air density based on https://icoads.noaa.gov/software/other/profs\nArgs: P (float): Air pressure in mbar T (float): Air temperature in degC RH (float): Air relative humidity*\n\n\n\n\nType\nDetails\n\n\n\n\nP\nfloat\nair pressure in mbar\n\n\nT\nfloat\nair temperature in degC\n\n\nRH\nfloat\nair relative humidity as %\n\n\n\n\nair_density(P=1015, #air pressure in mbar\n            T=20, #air temperature in degC\n            RH=50 #air relative humidity as %\n            )\n\n\nRunning cells with 'pyseatrials (Python 3.11.2)' requires the ipykernel package.\n\nRun the following command to install 'ipykernel' into the Python environment. \n\nCommand: '/home/jonno/venv/pyseatrials/bin/python -m pip install ipykernel -U --force-reinstall'",
    "crumbs": [
      "Basic hydro functions (basic)"
    ]
  },
  {
    "objectID": "wave_resistance.html",
    "href": "wave_resistance.html",
    "title": "Wave Resistance (wave)",
    "section": "",
    "text": "This section provides the functions necessary to calculate the resistance caused by waves",
    "crumbs": [
      "Wave Resistance (wave)"
    ]
  },
  {
    "objectID": "wave_resistance.html#stawave-1",
    "href": "wave_resistance.html#stawave-1",
    "title": "Wave Resistance (wave)",
    "section": "1 STAWAVE-1",
    "text": "1 STAWAVE-1\nSTAWAVE-1 s a simplficied method for ship experiencing limited heave and pitch it was developed by Boom, 2013, and is a practical solution due to its low calculation complexity and relatively small number of variables.\nSTAWAVE-1 has been validated and can be applied when following conditions are met\n\nHeave and Pitch are small with the vertical acceleration of the bow \\(&lt;0.05g \\approx 0.49ms^{-2}\\)\nThee wave direction \\(x\\) is between \\(-45^\\circ &lt;x &lt; -45^\\circ\\)\n\nITTC equations: G-1\n\nsource\n\n1.1 stawave1_fn\n\n stawave1_fn (beam:float, wave_height:float, length:float,\n              water_density:float=1026, gravity:float=9.81)\n\nSTAWAVE-1 finds the resistance caused by bow waves for ships experiencing low heave and pitch\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nbeam\nfloat\n\nthe beam of the ship [m]\n\n\nwave_height\nfloat\n\nSignificant wave height of wind waves [m]\n\n\nlength\nfloat\n\nThe length of the bow on the water line [m]. See documentation for more details\n\n\nwater_density\nfloat\n1026\nthis should be for the current temperature and salinity [kg/m^3]\n\n\ngravity\nfloat\n9.81\n\n\n\nReturns\nfloat\n\nWave resistance [kg*m/s^2]\n\n\n\n\nstawave1_fn(beam = 20, wave_height = 1, length =5)\n\n25162.65",
    "crumbs": [
      "Wave Resistance (wave)"
    ]
  },
  {
    "objectID": "wave_resistance.html#the-modified-pierson-moskowitz-spectrum",
    "href": "wave_resistance.html#the-modified-pierson-moskowitz-spectrum",
    "title": "Wave Resistance (wave)",
    "section": "2 The modified Pierson-Moskowitz spectrum",
    "text": "2 The modified Pierson-Moskowitz spectrum\nIn order to calcualte the force exerted on the vessel by the waves, the wave spectra must be calculate. For this the modified Pierson-Moskowitz spectrum [XXXcitationxxx] algorithm is typically used.\n\\[S_\\eta(\\omega) =\\frac{A_{fw}}{\\omega^5} \\textrm{exp}(-\\frac{B_{fw}}{\\omega^4})\\]\n\\[A_{fw} = 173\\frac{H_{W1/3}^2}{T_{01}^4}\\]\n\\[B_{fw} = \\frac{691}{T_{01}^4}\\]\nWhere\n\n\\(\\omega\\) is the circular frequency of regular waves\n\\(H_{W1/3}\\) is the significant wave height of swell and wind waves\n\\(T_{01}\\) is the wave encounter period\n\nITTC equations: 10\n\nsource\n\n2.1 modified_pierson_moskowitz_spectrum\n\n modified_pierson_moskowitz_spectrum (omega:float, H_W1_3:float)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nomega\nfloat\nThe circular frequency [rads/s]\n\n\nH_W1_3\nfloat\nSignificant wave height of Wind and Swell waves [m]\n\n\nReturns\nfloat\nThe energy density spectrum at the point omega [s]\n\n\n\nAs an example of the modified pierson moskowitz spectrum consider the case below\n\nomega = 1\nH_W1_3 = 2.0\nT_01 = 5.0\n\nS_eta = modified_pierson_moskowitz_spectrum(omega, H_W1_3)\nprint(S_eta)\n\n0.28499477886766",
    "crumbs": [
      "Wave Resistance (wave)"
    ]
  },
  {
    "objectID": "wave_resistance.html#stawave-2",
    "href": "wave_resistance.html#stawave-2",
    "title": "Wave Resistance (wave)",
    "section": "3 STAWAVE-2",
    "text": "3 STAWAVE-2\nThe resistance experienced by the ship from waves is calulated using the below process\nWave transfer function is given by \\[R_{wave} = R_{AWRL} + R_{AWML}\\]\nWhere\n\\[ R_{AWML} = \\frac{4 \\rho_s g \\zeta_A^2B^2}{ L_{pp} }\\bar{r}_{aw}(\\omega)   \\]\nwith\n\\[\\bar{r}_{aw}(\\omega) = \\bar{\\omega}^{b_1} \\textrm{exp}\\left\\{ \\frac{b_1}{d_1}(1 - \\omega^{-d_1}) \\right\\} a_1 \\textrm{Fr}^{1.5} \\textrm{exp}(3.50 \\textrm{Fr})\\]\n\\[\\bar{\\omega} = \\frac{\\sqrt{\\frac{L_{pp}}{g}}\\sqrt[3]{k_{yy}}}{1.17 \\textrm{Fr}^{-0.143}}\\omega\\]\n\\[a_1 = 60.3 C_B^{1.34} \\]\n\\[b_1 = \\begin{cases} 11.0 & \\bar{\\omega}&lt;1  \\\\ -8.5 & \\bar{\\omega}\\geq1 \\end{cases}\\]\n\\[d_1 = \\begin{cases} 14.0 & \\bar{\\omega}&lt;1  \\\\ -566(\\frac{L_{pp}}{B})^{-2.66} & \\bar{\\omega}\\geq1 \\end{cases}\\]\n\\[ R_{AWRL} = \\frac{1}{2} \\rho_s g \\zeta_A^2B \\alpha_1(\\omega) \\]\n\\[ \\alpha_1(\\omega) = \\frac{\\pi^2 I_1^2 ( 1.5 k T_M ) }{ \\pi^2 I_1^2 ( 1.5 k T_M ) + K_1^2 ( 1.5 k T_M ) }f_1 \\]\n\\[ f_1 = 0.692 \\left( \\frac{V_S}{\\sqrt{T_M g}} \\right)^{0.769} + 1.81 C_B^{6.95} \\]\nonce R_{AWRL}$, and \\(R_{AWML}\\)$ are obtained then the added resistance to the ship can be found by integrating the below equation. \\[R_{AWL} = 2\\int_{0}^{\\infty} \\frac{R_{wave}}{\\zeta_A^2}S_{\\eta}(\\omega)d\\omega\\]\nWhere the variables of the above equations are\n\n\\(B\\) Beam of ship\n\\(\\rho_s\\) water density at current ship conditions\n\\(g\\) force of gravity\n\\(Fr\\) Froude number\n\\(\\omega\\) wave frequency\n\\(k\\) ciruclar wave number in rads/s\n\\(S_eta\\) frequency spectrum of ocean waves. JONSWAP or ther methods can be used as appropriate.\n\\(C_B\\) block coefficient\n\\(V_s\\) ships speed in m/s\n\\(k_{yy}\\) non-dimensional radius of gyration in the lateral direction\n\\(L_{pp}\\) ship length between perpendiculars\n\\(T_M\\) draught at midship\n\\(I_t\\) modified Bessel Function of the first kind of order 1\n\\(K_t\\) modified Bessel Function of the second kind of order 1\n\\(\\zeta_A\\) The amplitude of the wave/significant wave height\n\nITTC equations: G-12\n\nsource\n\n3.1 R_AWL\n\n R_AWL (zeta_A:float, B:float, L_pp:float, V_s:float, T_M:float,\n        C_B:float, k_yy:float, Fr:float, k:float, rho_s:float=1025,\n        g:float=9.81, S_eta:object=None, **kwargs)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nzeta_A\nfloat\n\nwave amplitude [m]\n\n\nB\nfloat\n\nship breadth [m]\n\n\nL_pp\nfloat\n\nLength between perpendiculars [m]\n\n\nV_s\nfloat\n\nspeed through water [m/s]\n\n\nT_M\nfloat\n\ndraught at midship [m]\n\n\nC_B\nfloat\n\nblock coefficient [dimensionless]\n\n\nk_yy\nfloat\n\nradius of gyration in the lateral direction [dimensionless]\n\n\nFr\nfloat\n\nFroude number [dimensionless]\n\n\nk\nfloat\n\ncircular wave number [rads/m]\n\n\nrho_s\nfloat\n1025\nwater density [kg/m^3]\n\n\ng\nfloat\n9.81\naccerleation due to gravity [m/s^2]\n\n\nS_eta\nobject\nNone\nA function calculating the wave spectrum\n\n\nkwargs\n\n\n\n\n\nReturns\ntuple\n\nThe added wave resistance, the wave resistance from reflection, the wave resistsance from pitching\n\n\n\n\nsource\n\n\n3.2 calculate_R_wave\n\n calculate_R_wave (omega:float, C_B:float, L_pp:float, k_yy:float,\n                   Fr:float, zeta_A:float, B:float, k:float, T_M:float,\n                   V_s:float, rho_s:float=1025, g:float=9.81)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nomega\nfloat\n\ncircular wave frequency [rads/s]\n\n\nC_B\nfloat\n\nblock coefficient [dimensionless]\n\n\nL_pp\nfloat\n\nLength between perpendiculars [m]\n\n\nk_yy\nfloat\n\nradius of gyration in the lateral direction [dimensionless]\n\n\nFr\nfloat\n\nFroude number [dimensionless]\n\n\nzeta_A\nfloat\n\nwave amplitude [m]\n\n\nB\nfloat\n\nship breadth [m]\n\n\nk\nfloat\n\ncircular wave number [rads/m]\n\n\nT_M\nfloat\n\ndraught at midship [m]\n\n\nV_s\nfloat\n\nspeed through water [m/s]\n\n\nrho_s\nfloat\n1025\nwater density [kg/m^3]\n\n\ng\nfloat\n9.81\nacceleration due to gravity [m/s^2]\n\n\nReturns\ntuple\n\nFunction outputs the wave transfer function as well as the component parts R_AWRL and R_AWML\n\n\n\n\n# Ship parameters\nL_pp = 250  # meters\nV_s = 10  # meters per second\nbeaufort_scale = 5\nFr = 0.3\n\n# Example values for other parameters (adjust based on the specific ship)\nomega = 0.3 # circular wave frequency [rads/s]\ng = 9.81  # m/s^2, force of gravity\nk = omega * g # circular wave number [rads/m]\nrho_s = 1025  # kg/m^3, water density\nzeta_A = 1  # meters, significant wave height\nB = 32  # meters, beam of the ship\nC_B = 0.7  # block coefficient\nT_M = 12  # meters, draught at midship\nk_yy = 0.25  # non-dimensional radius of gyration in the lateral direction\nI_1 = iv(1, 1.5 * k * T_M)\nK_1 = kn(1,  1.5 * k * T_M) \n\n\n# Calculate R_wave\nR_wave = calculate_R_wave(omega, C_B, L_pp, k_yy, Fr, zeta_A, B, k, T_M, V_s, rho_s, g)\n\nR_wave\n\n(229776.13823059603, 128975.85056996053, 100800.2876606355)\n\n\n\nR_AWL(zeta_A, B, L_pp, V_s, T_M, C_B, k_yy, Fr, k, rho_s, g, S_eta = modified_pierson_moskowitz_spectrum, H_W1_3 = zeta_A)\n\n(14670.472278183037, 8072.656348988186, 6597.815929194849)\n\n\n\nimport matplotlib.pyplot as plt\n\n\ntransfer_function = lambda omega: (calculate_R_wave(omega = omega, C_B = C_B, L_pp = L_pp, k_yy = k_yy, \n                                                    Fr = Fr , zeta_A = zeta_A, B = B, k = k, T_M = T_M, V_s = V_s, rho_s = rho_s, g = g))\n\nmultipliers = [3, 2, 1, 1/2, 1/4, 1/8]\n\npierson2 = lambda omega: modified_pierson_moskowitz_spectrum(omega, H_W1_3)\nx = np.linspace(0.1, 3, 1000)\ny = (np.array([transfer_function(z) for z in x]))\ny2 = (np.array([pierson2(z) for z in x]))\n\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, linewidth=2.0)\n\nplt.show()",
    "crumbs": [
      "Wave Resistance (wave)"
    ]
  }
]
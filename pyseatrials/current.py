# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_current.ipynb.

# %% auto 0
__all__ = ['estimate_speed_through_water', 'current_mean_of_means']

# %% ../nbs/06_current.ipynb 2
import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt

# %% ../nbs/06_current.ipynb 8
def estimate_speed_through_water(P_id, V_g, t, T_c, tolerance=1e-6, max_iter=1000):

    def current_speed(t, V_c_C, V_c_S, V_c_T, V_c_0, T_c):
        return V_c_C * np.cos((2 * np.pi / T_c) * t) + V_c_S * np.sin((2 * np.pi / T_c) * t) + V_c_T * t + V_c_0

    def power_eq(V_s, a, b, q):
        return a + b * V_s**q
    #get initial estimates for the power law curve parameters
    popt, _ = curve_fit(power_eq, V_g, P_id, p0=[1, 1, 1])
    a, b, q = popt
    
    for i in range(max_iter):
        # Calculate stw
        V_s = np.power((P_id - a) / b, 1/q)
        
        # Calculate current
        V_c = V_g - V_s
        
        # FCalucalte current coefs using curve fitting
        popt, _ = curve_fit(lambda t, V_c_C, V_c_S, V_c_T, V_c_0: current_speed(t, V_c_C, V_c_S, V_c_T, V_c_0, T_c), t, V_c, p0=[1, 1, 1, 1])
        
        # Update V_c_C, V_c_S, V_c_T, V_c_0 using the fitted parameters
        V_c_C, V_c_S, V_c_T, V_c_0 = popt
        
        # Calculate the new current using fitted params
        V_c_new = current_speed(t, V_c_C, V_c_S, V_c_T, V_c_0, T_c)
        
        # Update update stw
        V_s = V_g - V_c_new
        
        # Update the power law parameters a, b, and q using curve fitting and new stw estimate
        popt, _ = curve_fit(power_eq, V_s, P_id, p0=[a, b, q])
        a, b, q = popt
        
        #calculates estimated power using new power law curve
        P_obs = a + b * V_s ** q
        #compare error
        power_error = sum((P_obs - P_id) ** 2)
        
        # Check convergence
        if power_error < tolerance:
            break
    
    return V_s



# %% ../nbs/06_current.ipynb 11
def current_mean_of_means(list_of_speeds:list, # The mean speed over ground across a double run,
                           start_time:float, # Time in decimal hours when the first run took place,
                           time_between_runs:float #Time in decimal hours between each run. Note the time difference must be consistent between all runs
                          ):

    t = start_time
    delta_t = time_between_runs/2

    V_G1, V_G2, V_G3, V_G4 = list_of_speeds
    Vs = (V_G1 + 3 * V_G2 + 3 * V_G3 + V_G4) / 8

    A = np.array([  [(t + 3*delta_t)**2, -(t + 3*delta_t), 1],
                    [(t + 1*delta_t)**2, -(t + 1*delta_t), 1],
                    [(t - 1*delta_t)**2, -(t - 1*delta_t), 1],
                    [(t - 3*delta_t)**2, -(t - 3*delta_t), 1]])

    b = np.array([V_G1 - Vs, V_G2 - Vs, V_G3 - Vs, V_G4 - Vs])

    x, residuals, rank, singular_values = np.linalg.lstsq(A, b, rcond=None)


    return x, residuals


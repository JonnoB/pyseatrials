# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/09_trig.ipynb.

# %% auto 0
__all__ = ['opposite_magnitude_fn', 'adjacent_magnitude_fn', 'combine_vectors', 'law_of_cosines', 'find_gamma_fn']

# %% ../nbs/09_trig.ipynb 4
import numpy as np
import pandas as pd
from fastcore.test import *

# %% ../nbs/09_trig.ipynb 6
def opposite_magnitude_fn(magnitude:float, #The true speed 
                             angle:float, #The angle in radians
                            ) -> int: #The vertical component of the magnitude
    "Product of sin and magnitude"
    
    x = magnitude * np.sin(angle)
    
    return x

# %% ../nbs/09_trig.ipynb 9
def adjacent_magnitude_fn(magnitude:float, # The true speed
                             angle:float, # The Ange in radians
                             ) -> int: #The adjacent component of the magnitude
    
    "Product of cos and magnitude"
    
    x = magnitude * np.cos(angle)
    
    return x

# %% ../nbs/09_trig.ipynb 13
def combine_vectors(a:float, # magnitude of vector a
                    b:float,  #magnitude of vector b
                    alpha:float, #angle of vector a
                    beta:float #angle of vector b
                    ) -> float: # the magnitude and anngle of the new vector

    "Combine two 2-dimensional vectors into a new vector"
    #Temproary vectors which are removed when the function completes
    adj = a*np.cos(alpha) +  b*np.cos(beta)
    opp = a*np.sin(alpha) +  b*np.sin(beta)
    magnitude = np.sqrt(adj**2 + opp**2)

    #some values will be negative, is this a problem?
    gamma = np.arctan2(opp, adj)

    return magnitude, gamma

# %% ../nbs/09_trig.ipynb 16
def law_of_cosines(a:float, # side a which is along the x-axis
                   b:float, #side b makes the angle $\theta$ with side a
                   theta:float  #the angle in radians opposite side c
                  ) -> float: #The magnitude of b relative to a
    
    "Finds the length of side c using the angle theta opposite c and the length of the other two sides"
    
    adjacent_component = a - adjacent_magnitude_fn(b, theta)
    opposite_component = - opposite_magnitude_fn(b, theta)
    
    return np.sqrt(adjacent_component**2 + opposite_component**2)

# %% ../nbs/09_trig.ipynb 20
def find_gamma_fn(a:int, #magnitude of a 
                  b:int, #magnitude of b
                  alpha:int, # the angle between b and a in radians
                  constrain_to_positive:bool = False #Should the function return a value between 0 and 2 pi
                 ) -> int:   #the angle in radians between a and the relative magnitude of b
    
        adjacent_component = b + adjacent_magnitude_fn(a, alpha)
        opposite_component = opposite_magnitude_fn(a, alpha)
        
        gamma = np.arctan2(opposite_component, adjacent_component)
        
        #prevents negative angles if constrain to positive is true
        #using this method instead of an if statement means the function can perform vectorised operations
        gamma = gamma + 2*np.pi*(gamma<0)*constrain_to_positive
        
        return gamma

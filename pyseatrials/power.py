# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_power.ipynb.

# %% auto 0
__all__ = ['correction_delivered_power', 'propulsive_efficiency_corr', 'full_scale_wake_fraction', 'full_scale_wake_speed',
           'scale_correlation_factor', 'self_propulsion_factors', 'get_curve_coefficient', 'torque_coef',
           'propeller_advance_coefficient', 'open_water_efficiency', 'propeller_flow']

# %% ../nbs/04_power.ipynb 3
import numpy as np
from fastcore.test import *

# %% ../nbs/04_power.ipynb 5
def correction_delivered_power(
    p_dms:float, #delivered power [W]
    resistance_increase:float, #Resistance increase derived from data measured in seatrial
    stw:float, #speed through water [m/s]
    eta_id:float, #propulsive efficiency in the ideal conditions
    eta_ms:float, # propulsive efficiency in the seattrial

)-> float:
    
    "calculates the corrected delivered power, used as part of the direct power analysis"
    
    return resistance_increase * stw /eta_id + p_dms * (1- eta_ms/eta_id)
    

# %% ../nbs/04_power.ipynb 9
def propulsive_efficiency_corr(n_o:float, #open water efficiency
                          n_r:float, #relative rotative efficiency
                          t:float, #thrust deduction factor
                         w_s:float, #full-scale wake fraction
                         ):
    "Calculates propeller efficiency adjusting for additional resistances"
    return n_o*n_r*(1-t)/(1-w_s)
    

# %% ../nbs/04_power.ipynb 13
def full_scale_wake_fraction(wake_fraction_model:float,
                            scale_correlation_factor:float
                            )-> float:
    
    "used to scale from model results to full-scale vessel"
    
    return 1- (1- wake_fraction_model) * scale_correlation_factor

# %% ../nbs/04_power.ipynb 18
def full_scale_wake_speed(flow_speed:float, #The speed of flow through the propeller
                         stw:float, #Ship's speed through water
                         )-> float:
    
    "Calculate the wake fraction using the measured water speeds"
    
    return 1 - (flow_speed/stw)

# %% ../nbs/04_power.ipynb 23
def scale_correlation_factor(
    trial:float, #The full-scale wake fraction in the trial
    model:float  #The wake fraction of the model derived from tank tests
)-> float: #The dimensionless coefficient joining the full scale and model fractions
    "Calcualte the scale correlation factor using the model fraction from tank tests, and the full-scale fraction from trials"
    return (1  - trial)/(1-model)

# %% ../nbs/04_power.ipynb 28
def self_propulsion_factors(
    x_ideal:float, #The variable in ideal conditions. It is acceptable to use this value without adjustments
    delta_x:float = 0, #The change per unit of the resistance ratios. Default is 0
    delta_r:float = 1, #increase in resistance from ideal conditions
    delta_r_ideal:float = 1 #Resistance in ideal conditions
) -> float:
    
    "Adjusting the self propulsion factors is only possible if the required model tests have been performed. By default this function returns the ideal value"
    
    return x_ideal + delta_x * (delta_r/delta_r_ideal)

# %% ../nbs/04_power.ipynb 33
def get_curve_coefficient(y:float, #The dependent variable coefficient
                      x:float #The propeller advance coefficient
                     )->float: #returns model coefficients
    
    "Obtain the coefficients used to calculate the Thrus, and Torque coefficients and the load factor coefficients"
    
    #create the X matrix to have a quadratic form
    X = np.concatenate((x**2,x, np.ones(len(x)))).reshape([3,10]).transpose()
    #Get determinate

    square_mat = np.matmul(X.transpose(), X)

    detX = np.linalg.inv(square_mat)

    temp = np.matmul(detX, np.transpose(X))
    #Return the beta value
    b = np.matmul(temp, y)
    
    return b
    

# %% ../nbs/04_power.ipynb 40
def torque_coef(power:float, #The delivered power
                     shaft_speed:float, #measure propeller shaft speed [rev/s]
                     diameter:float, #properller_diameter [m]
                     efficiency:float, #relative rotative efficiency
                     water_density:float = 1026 #water density [kg/m^3]
                     )->float: #dimensionless thrust coefficient
    
    "calcualte the torque coefficient under ideal or trial conditions"
    
    denominator = 2 * np.pi * shaft_speed * diameter
    
    return (power/denominator) *  efficiency
    
    

# %% ../nbs/04_power.ipynb 45
def propeller_advance_coefficient(torque_coefficient:float, #The torque coefficient
                                  a:float, #coefficient 'a' from get_curve_coefficient
                                  b:float, #coefficient 'b' from get_curve_coefficient
                                  c:float #coefficient 'c' from get_curve_coefficient

                                  ) -> float:
    
    "Calculate the propeller advance coefficient for"
    square_root = np.sqrt(b**2 - 4*a*(c - torque_coefficient))
    
    return (-b - square_root )/(2*a)

# %% ../nbs/04_power.ipynb 50
def open_water_efficiency(propeller_advance_coef:float, #The propeller advance coefficient of the ship
                         thrust_coef:float, # thrust coefficient
                         torque_coef:float 
                         )-> float:
    
    "Calculate the open water propeller efficiency"
    
    return (propeller_advance_coef/(2*np.pi))*(thrust_coef/torque_coef)

# %% ../nbs/04_power.ipynb 55
def propeller_flow(
    propeller_advance_coef:float, #Propeller advance coefficient [n/a]
    rotations_sec:float, #propeller rotations per second [rev/sec]
    diameter:float, #Diamter of the propeller [m]
    )-> float: #The value that comes out is in m3/s WHAT ARE THE UNITS?
    
    "Calculate water flow into the propeller"
    
    return propeller_advance_coef * rotations_sec *diameter

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_shallow_water.ipynb.

# %% auto 0
__all__ = ['shallow_water_correction']

# %% ../nbs/07_shallow_water.ipynb 7
def shallow_water_correction(Cv_prime: float, rho: float, Vs: float, S: float, T_M: float, h: float, 
                             L_pp: float, B: float, C_B: float, P_D_shallow: float, eta_Did: float, R_V_deep=None) -> tuple[float, float, float]:
    """
    Perform Raven corrections for shallow water performance

    """
    # Calculate viscous friction in deep water if not provided
    if R_V_deep is None:
        R_V_deep = Cv_prime * 0.5 * rho * Vs**2 * S
    
    # Calculate the viscous resistance correction
    R_V = R_V_deep * 0.57 * (T_M / h)**1.79
    
    # Calculate the sinkage
    displacement = L_pp * B * T_M * C_B
    Fr_h = Vs / np.sqrt(9.81 * 0.3 * L_pp)
    Fr_hd = Vs / np.sqrt(9.81 * h)
    sinkage = 1.46 * displacement / L_pp**2 * (Fr_h**2 / (1 - Fr_h**2) - Fr_hd**2 / (1 - Fr_hd**2))
    sinkage = max(sinkage, 0)
    
    # Calculate additional displacement due to sinkage
    A_W = L_pp * B
    #delta displacement is written like this to allow vectorisation
    delta_displacement = np.minimum(sinkage * A_W / displacement, 0.05)
    
    # Calculate rsink
    rsink = (1 - delta_displacement)**(2/3)
    
    # Calculate deep water power
    P_D_deep = (P_D_shallow / rsink) - (R_V * Vs / eta_Did)
    
    # Check if the condition is met
    condition_met = R_V_deep <= P_D_deep * eta_Did / Vs
    
    # If the condition is not met, set R_V_deep to the upper limit and repeat the process
    if not condition_met:
        R_V_deep = P_D_deep * eta_Did / Vs
        P_D_deep, sinkage, R_V = shallow_water_correction(Cv_prime, rho, Vs, S, T_M, h, L_pp, B, C_B, P_D_shallow, eta_Did, R_V_deep)
    
    return P_D_deep, sinkage, R_V


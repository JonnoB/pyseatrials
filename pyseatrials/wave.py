# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_wave_resistance.ipynb.

# %% auto 0
__all__ = ['stawave1_fn', 'modified_pierson_moskowitz_spectrum', 'calculate_R_wave', 'R_AWL']

# %% ../nbs/03_wave_resistance.ipynb 2
import numpy as np
from scipy.integrate import quad
from scipy.special import iv, kn
from fastcore.test import *

# %% ../nbs/03_wave_resistance.ipynb 4
def stawave1_fn(
    beam:float, #the beam of the ship [m]
    wave_height:float, #Significant wave height of wind waves [m]
    length:float, #The length of the bow on the water line [m]. See documentation for more details
    water_density:float = 1026, #this should be for the current temperature and salinity [kg/m^3]
            gravity:float  = 9.81
            )-> float: # Wave resistance [kg*m/s^2]
    
    "STAWAVE-1 finds the resistance caused by bow waves for ships experiencing low heave and pitch"
    
    
    return (1/16)* water_density * gravity * wave_height**2 * beam * np.sqrt(beam/length)
    

# %% ../nbs/03_wave_resistance.ipynb 8
def modified_pierson_moskowitz_spectrum(omega:float, #The circular frequency [rads/s]
                                        H_W1_3:float, #Significant wave height of Wind and Swell waves [m]
                                        #T_01:float#
                                        )->float: #The energy density spectrum at the point omega [s]
    
    T_01 = 2*np.pi * omega
    A_fw = 173 * (H_W1_3 ** 2) / (T_01 ** 4)
    B_fw = 691 / (T_01 ** 4)
    S_eta = (A_fw / (omega ** 5)) * np.exp(-B_fw / (omega ** 4))
    return S_eta

# %% ../nbs/03_wave_resistance.ipynb 12
def _a_1(C_B):
    return 60.3 * C_B**1.34

def _bar_omega_fn(omega, L_pp, g, k_yy, Fr):
    return (np.sqrt(L_pp / g) * (k_yy**(1/3))) / (1.17 * Fr**(-0.143))*omega

def _b_1(bar_omega):

    logical_test = (bar_omega < 1)

    return (logical_test *11.0) + (~logical_test) *-8.5

def _d_1(bar_omega, L_pp, B):

    logical_test = (bar_omega < 1)

    return (logical_test *14.0) + (~logical_test) *(-566 * (L_pp / B)**(-2.66))

def _r_aw(bar_omega, b_1, d_1, a_1, Fr):
    return (bar_omega**b_1) * np.exp((b_1 / d_1) * (1 - bar_omega**(d_1))) * a_1 * Fr**1.5 * np.exp(3.50 * Fr)

def _R_AWML(rho_s, g, zeta_A, B, L_pp, r_aw):
    return ((4 * rho_s * g * zeta_A**2 * B**2) / L_pp ) * r_aw


def _f_1(V_S, T_M, g, C_B):
    return 0.692 * (V_S / np.sqrt(T_M * g))**0.769 + 1.81 * C_B**6.95

def _alpha_1(I_1, K_1, f1):
    return ((np.pi**2 * I_1**2 ) / (np.pi**2 * I_1**2  + K_1**2 ))*f1


def _R_AWRL(rho_s, g, zeta_A, B, alpha_1):
    return 0.5 * rho_s * g * zeta_A**2 * B * alpha_1

# %% ../nbs/03_wave_resistance.ipynb 13
def calculate_R_wave(omega:float, # circular wave frequency [rads/s]
                     C_B:float, # block coefficient [dimensionless]
                     L_pp:float, # Length between perpendiculars [m]
                     k_yy:float, # radius of gyration in the lateral direction [dimensionless]
                     Fr:float, # Froude number [dimensionless]
                     zeta_A:float, # wave amplitude [m]
                     B:float, # ship breadth [m]
                     k:float, # circular wave number [rads/m]
                     T_M:float, # draught at midship [m]
                     V_s:float, # speed through water [m/s]
                     rho_s:float = 1025, # water density [kg/m^3]
                     g:float = 9.81 # acceleration due to gravity [m/s^2]
                     ) -> tuple: #Function outputs the wave transfer function as well as the component parts R_AWRL and R_AWML
    a1 = _a_1(C_B)
    bar_omega = _bar_omega_fn(omega, L_pp, g, k_yy, Fr)
    b1 = _b_1(bar_omega)
    d1 = _d_1(bar_omega, L_pp, B)
    r_aw_val = _r_aw(bar_omega, b1, d1, a1, Fr)
    R_AWML_val = _R_AWML(rho_s, g, zeta_A, B, L_pp, r_aw_val)
    
    I_1 = iv(1, 1.5 * k * T_M)
    K_1 = kn(1, 1.5 * k * T_M) 
    f1 = _f_1(V_s, T_M, g, C_B)
    alpha1 = _alpha_1(I_1, K_1, f1)
    R_AWRL_val = _R_AWRL(rho_s, g, zeta_A, B, alpha1)
    R_wave = R_AWRL_val + R_AWML_val
    
    return R_wave, R_AWRL_val, R_AWML_val

def R_AWL(#omega:float, # circular wave frequency [rads/s]
          zeta_A:float, # wave amplitude [m]
          B:float, # ship breadth [m]
          L_pp:float, # Length between perpendiculars [m]
          V_s:float, # speed through water [m/s]
          T_M:float, # draught at midship [m]
          C_B:float, # block coefficient [dimensionless]
          k_yy:float, # radius of gyration in the lateral direction [dimensionless]
          Fr:float, # Froude number [dimensionless]
          k:float, # circular wave number [rads/m]
          rho_s:float = 1025, # water density [kg/m^3]
          g:float = 9.81, # accerleation due to gravity [m/s^2]
          S_eta:object = None, #A function calculating the wave spectrum 
          **kwargs)->tuple: # The added wave resistance, the wave resistance from reflection, the wave resistsance from pitching
    
    def integrand(omega: float) -> tuple:
        R_wave, R_AWRL_val, R_AWML_val = calculate_R_wave(omega = omega, C_B = C_B, L_pp = L_pp, k_yy = k_yy, 
                                                          Fr = Fr , zeta_A = zeta_A, B = B, k = k, T_M = T_M, 
                                                          V_s = V_s, rho_s = rho_s, g = g)
        common_factor = (2 / (zeta_A**2)) * S_eta(omega, **kwargs)
        return common_factor * R_wave, common_factor * R_AWRL_val, common_factor * R_AWML_val

    def integrand_n(omega: float, n: int) -> float:
        return integrand(omega)[n]

    result_0, _ = quad(lambda omega: integrand_n(omega, 0), 0, np.inf)
    result_1, _ = quad(lambda omega: integrand_n(omega, 1), 0, np.inf)
    result_2, _ = quad(lambda omega: integrand_n(omega, 2), 0, np.inf)
    
    return result_0, result_1, result_2
